<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Treinamento Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="treinamento.html"><strong aria-hidden="true">1.</strong> Treinamento</a></li><li class="chapter-item expanded "><a href="instalação.html"><strong aria-hidden="true">2.</strong> Instalação</a></li><li class="chapter-item expanded "><a href="introdução.html"><strong aria-hidden="true">3.</strong> Introdução</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">4.</strong> Hello word</a></li><li class="chapter-item expanded "><a href="tipos_de_variáveis.html"><strong aria-hidden="true">5.</strong> Tipos de variáveis</a></li><li class="chapter-item expanded "><a href="trabalhando_com_strings.html"><strong aria-hidden="true">6.</strong> Trabalhando com Strings</a></li><li class="chapter-item expanded "><a href="funções,_testes_unitários_e_doc.html"><strong aria-hidden="true">7.</strong> Funções, testes unitários e doc</a></li><li class="chapter-item expanded "><a href="controle_de_fluxo.html"><strong aria-hidden="true">8.</strong> Controle de fluxo (if, while, for)</a></li><li class="chapter-item expanded "><a href="declarar_objetos.html"><strong aria-hidden="true">9.</strong> Declarar objetos</a></li><li class="chapter-item expanded "><a href="enumerados.html"><strong aria-hidden="true">10.</strong> Enumerados</a></li><li class="chapter-item expanded "><a href="ownership_e_borrowing.html"><strong aria-hidden="true">11.</strong> Ownership e borrowing</a></li><li class="chapter-item expanded "><a href="collections_e_iterators.html"><strong aria-hidden="true">12.</strong> Collections e Iterators</a></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">13.</strong> Option (opcional)</a></li><li class="chapter-item expanded "><a href="tratamento_de_erro.html"><strong aria-hidden="true">14.</strong> Tratamento de erro</a></li><li class="chapter-item expanded "><a href="trabalhando_com_result.html"><strong aria-hidden="true">15.</strong> Trabalhando com Result</a></li><li class="chapter-item expanded "><a href="exercícios.html"><strong aria-hidden="true">16.</strong> Exercícios</a></li><li class="chapter-item expanded "><a href="CLI_structopt.html"><strong aria-hidden="true">17.</strong> CLI structopt</a></li><li class="chapter-item expanded "><a href="manipular_json.html"><strong aria-hidden="true">18.</strong> Manipulação JSON</a></li><li class="chapter-item expanded "><a href="arquivos.html"><strong aria-hidden="true">19.</strong> Leitura e gravação de arquivos</a></li><li class="chapter-item expanded "><a href="date_time.html"><strong aria-hidden="true">20.</strong> Date time</a></li><li class="chapter-item expanded "><a href="smart_pointers.html"><strong aria-hidden="true">21.</strong> Smart pointers</a></li><li class="chapter-item expanded "><a href="threads.html"><strong aria-hidden="true">22.</strong> Threads</a></li><li class="chapter-item expanded "><a href="sintaxe_async.html"><strong aria-hidden="true">23.</strong> Sintaxe async</a></li><li class="chapter-item expanded "><a href="sqlx.html"><strong aria-hidden="true">24.</strong> SQLx (acesso BD)</a></li><li class="chapter-item expanded "><a href="traits.html"><strong aria-hidden="true">25.</strong> Traits (interfaces)</a></li><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">26.</strong> Closures</a></li><li class="chapter-item expanded "><a href="estrutura_de_diretórios.html"><strong aria-hidden="true">27.</strong> Estrutura de diretórios</a></li><li class="chapter-item expanded "><a href="clonar_structs.html"><strong aria-hidden="true">28.</strong> Clonar structs</a></li><li class="chapter-item expanded "><a href="api_design.html"><strong aria-hidden="true">29.</strong> API design</a></li><li class="chapter-item expanded "><a href="debug.html"><strong aria-hidden="true">30.</strong> Debug</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Treinamento Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="funcionamento-do-treinamento"><a class="header" href="#funcionamento-do-treinamento">Funcionamento do treinamento</a></h2>
<p>Bem vindo ao treinamento da linguagem Rust.</p>
<p>O layout do treinamento é no formato <em>book</em>, dividido em capítulos.</p>
<p>À esquerda possui a lista dos capítulos que podem ser navegados.</p>
<p>Para navegar entre os capítulos anteriores e próximos é possível utilizar as setas <code>&lt;</code> <code>&gt;</code> na área principal do texto.</p>
<p>No topo superior existem ícones para ocultar a lista de capítulos, mudar o tema (inclusive para tema claro e escuro) e pesquisar conteúdo sobre o livro.</p>
<h3 id="preparação-para-o-treinamento"><a class="header" href="#preparação-para-o-treinamento">Preparação para o treinamento</a></h3>
<h3 id="instalação-no-windows"><a class="header" href="#instalação-no-windows">Instalação no Windows</a></h3>
<p>Para instalação no Windows siga os seguintes passos:</p>
<ul>
<li>
<p>Baixe o <a href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">instalador do Rust 64 bits</a>.</p>
</li>
<li>
<p>Selecione a opção padrão:</p>
</li>
</ul>
<p><img src="image/rust-install.png" alt="Selecionar opção padrão" /></p>
<ul>
<li>
<p>O compilador do Rust precisa de um linker externo, para isso baixe o <a href="https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&amp;rel=16">instalador do Visual Studio</a>.</p>
</li>
<li>
<p>Selecione Build Tools for Visual Studio 2019:</p>
</li>
</ul>
<p><img src="image/download-vs-build-tools.png" alt="Selecionar Visual Studio" /></p>
<ul>
<li>Para reduzir o tamanho da instalação do Visual Studio selecione:</li>
</ul>
<p><img src="image/required-components.png" alt="Selecionar itens" /></p>
<h3 id="verificando-instalação"><a class="header" href="#verificando-instalação">Verificando instalação</a></h3>
<p>Configure se instalou o compilador corretamente:</p>
<pre><code class="language-terminal">rustc --version
</code></pre>
<h3 id="instalação-no-wsl-ou-linux"><a class="header" href="#instalação-no-wsl-ou-linux">Instalação no WSL ou Linux</a></h3>
<p>No terminal do Windows entrar no WSL através do comando <code>wsl</code></p>
<p>Instalar requisito para o Rust:</p>
<pre><code class="language-terminal">sudo apt install build-essential
sudo apt install libssl-dev
</code></pre>
<p>Instalar o Rust:</p>
<pre><code class="language-terminal">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Confirme todas opções com o <em>default</em>. Ao final execute o comando para atualizar a variáveis de ambiente necessárias:</p>
<pre><code class="language-terminal">source $HOME/.cargo/env
</code></pre>
<h3 id="extensões-do-vscode"><a class="header" href="#extensões-do-vscode">Extensões do VSCode</a></h3>
<p>Edição de fonte de dentro do WSL:</p>
<pre><code>ms-vscode-remote.remote-wsl
</code></pre>
<p>Edição de fonte em VM Linux:</p>
<pre><code>ms-vscode-remote.remote-ssh
</code></pre>
<p>Language Server do Rust:</p>
<pre><code>matklad.rust-analyzer
</code></pre>
<p>Formator de arquivos toml:</p>
<pre><code>bungcip.better-toml
</code></pre>
<p>Debuger do Rust:</p>
<pre><code>vadimcn.vscode-lldb
</code></pre>
<p>Auxiliar do Cargo:</p>
<pre><code>panicbit.cargo
</code></pre>
<p>Validador de dependências Crates</p>
<pre><code>serayuzgur.crates
</code></pre>
<p>Error lens:</p>
<pre><code>usernamehw.errorlens
</code></pre>
<h3 id="configurações-do-vscode"><a class="header" href="#configurações-do-vscode">Configurações do VSCode</a></h3>
<p>Adicionar no <code>settings.json</code>:</p>
<pre><code>&quot;rust-analyzer.checkOnSave.command&quot;: &quot;clippy&quot;,
&quot;rust-analyzer.diagnostics.disabled&quot;: [&quot;macro-error&quot;],
</code></pre>
<h3 id="playground-execução-via-web"><a class="header" href="#playground-execução-via-web"><em>Playground</em> (execução via web)</a></h3>
<p>Para testes rápidos pode ser útil usar o <em>playground</em> do Rust:</p>
<p><a href="https://play.rust-lang.org/">Rust Playground</a></p>
<p><img src="image/rust-logo.jpg" alt="Rust logo" /></p>
<h2 id="introdução"><a class="header" href="#introdução">Introdução</a></h2>
<p>A Programação Orientada a Objetos aumentou a produtividade em comparação a Programação Estruturada, principalmente devido a sua característica de abstração que permite um
entendimento mais próximos à realidade humana.
Entretanto programar com objetos envolve trabalhar com referências, que com o passar do
tempo se provou criar uma série de problemas que antes não existiam.
Podemos fazer uma analogia ao COBOL estruturado, quando que ocorreria um <em>null pointer exception</em> ou <em>memory leak</em>?</p>
<blockquote>
<p>De acordo com engenheiros do Google e da Microsoft, 70% dos bugs são causados por erros ao manipular memória e objetos.</p>
</blockquote>
<p>Nesse aspecto podemos dizer que Programação Estruturada é mais segura que a POO.</p>
<h2 id="por-que-rust"><a class="header" href="#por-que-rust">Por que Rust?</a></h2>
<p>Rust surgiu para permitir programar através de vários paradigmas sem correr os riscos de manipular referências.</p>
<p>O inventor do conceito de <em>null</em>, Tony Hoare, hoje considera que esse foi o seu <a href="http://blog.mattcallanan.net/2010/09/tony-hoare-billion-dollar-mistake.html">erro de 1 bilhão de dólares</a>,
devido ao custo de ter que prevê-lo, o custo do efeito negativo de quando ocorre erro e mais o custo para corrigi-lo.
Rust é uma das poucas linguagens que conseguiu eliminar definitivamente o uso do <em>null</em>.</p>
<p>O compilador impede muitos bugs em tempo de compilação, inclusive concorrência entre <em>threads</em>.
Isso permite que sejam criados programas <strong>extremamente robustos</strong>.</p>
<p>O compilador do Rust traz para si a responsabilidade de impedir erros, tirando o máximo possível das mãos do programador. Inclusive o controle de alocação de memória.
Pelo fato do compilador resolver esta alocação em tempo de compilação, acaba sendo desnecessário haver <em>Garbage Collection</em>.
Além disso, boa parte das variáveis são alocadas na memória <em>stack</em>, que é bem mais rápida que a memória <em>heap</em>. Outra característica do compilador é o <em>zero-cost abstraction</em>, onde a maneira que o programador estrutura o código não afeta o resultado final.
Como resultado de tudo isso seus programas são <strong>extremamente rápidos</strong>.</p>
<p><strong>Rust é uma linguagem inovadora, pois é a única que conseguiu conciliar alto desempenho com segurança.</strong></p>
<p><img src="image/performance-seguran%C3%A7a.png" alt="Body frame" /></p>
<blockquote>
<p>Segundo engenheiros do Facebook, para adotar uma tecnologia não basta ser um pouco melhor, tem que ser muito melhor.</p>
</blockquote>
<p>Existe um custo para aprender e outro custo contínuo para mantê-la.
Engenheiros do Facebook consideram Rust uma linguagem &quot;10 vezes&quot; melhor do que outras:
<strong>o custo de se detectar um bug em compilação é de várias ordens menor do que em execução ou em produção</strong>.</p>
<p>Rust é <em>free</em> e <em>opensource</em>. Gera código binário nativo para diversas plataformas.
Não possui <em>runtime</em> nem <em>virtual machine</em>, ou seja, seu executável pode ser executado de maneira
muito simples. Possui moderno gerenciador de pacotes e grande variedade de bibliotecas.</p>
<h2 id="rust-é-baixo-nível"><a class="header" href="#rust-é-baixo-nível">Rust é baixo nível?</a></h2>
<p>Rust é uma linguagem multi-paradigma, permite trabalhar de forma estruturada, orientada a objetos e funcional.
Existe um mito que Rust serve somente para baixo nível.
Na verdade serve tanto para baixo nível quanto para alto nível, onde podemos afirmar que
<strong>Rust é uma das linguagens mais completas que existe</strong>.
Alguns consideram como alternativa ao C++ e outros como alternativa ao Go.
Rust possui várias abstrações de alto nível, algumas inclusive que não existem em outras linguagens.</p>
<p><img src="image/baixo-alto-n%C3%ADvel.png" alt="Body frame" /></p>
<blockquote>
<p>No Facebook inicialmente pensou-se que Rust seria adotado mais facilmente por programadores de C++,
porém foram os programadores de Python que mais se identificaram com a linguagem.</p>
</blockquote>
<h2 id="curva-de-aprendizado-e-complexidade"><a class="header" href="#curva-de-aprendizado-e-complexidade">Curva de aprendizado e complexidade</a></h2>
<p>Por permitir fazer um monte de coisas é natural ter mais coisas para aprender.
Podemos comparar ao COBOL, com uma curva de aprendizado semelhante.</p>
<blockquote>
<p>O Facebook concluiu que seus programadores demoravam até dois meses para se sentirem produtivos.</p>
</blockquote>
<p>Então não devemos nos frustrar em não aprender Rust em uma semana.
E como em muitas linguagens, não precisamos aprender tudo para desenvolver algumas aplicações.
Por exemplo, um programador Java não precisa dominar <em>generics</em>, interfaces, <em>lambdas</em> e <em>threads</em> para fazer alguns programas.
Rust, por permitir vários paradigmas, pode fornecer algumas opções para contornarmos e alcançarmos o objetivo.</p>
<p>Criar <em>software</em> seguro envolve uma dedicação maior a curto prazo, mas ao longo prazo ganha-se tempo por gerar menos manutenção.
Pense a construção de <em>software</em> como sendo uma construção de um prédio.
É mais fácil ir empilhando somente tijolos do que fazer vigas e colunas.
Porém se for só empilhar tijolos, assim que vai subindo os andares as coisas começam a ficar mais perigosas.
Rust funciona mais ou menos assim: a construção é mais rigorosa, mas permite expandir de uma forma bem mais robusta.</p>
<p>Aprender a programar em Rust é como aprender a programar pela primeira vez.
Muitos dos conceitos que aprendemos em outras linguagens não ajudarão, inclusive
eventualmente teremos que desaprender algumas coisas.</p>
<blockquote>
<p>Um fato que vale a pena reforçar: se você está fazendo algo errado em Rust o programa simplesmente não compila.
Em outras linguagens <em>não fazer certo</em> muitas vezes é sinônimo de <em>erro de execução</em>. Em Rust isso dificilmente ocorre.
Ou seja, se alguém tiver dificuldade em aprender Rust não significa que ele estará fazendo programas errados.
<strong>Pode ser difícil programar em Rust, mas é muito fácil de programar certo em Rust.</strong></p>
</blockquote>
<h2 id="production-ready"><a class="header" href="#production-ready"><em>Production ready</em></a></h2>
<p>Rust começou a ser desenvolvida em 2010 e a versão 1.0 foi lançada em 2015.
Hoje Rust é usado em produção por grandes empresas, tal como AWS, Microsoft, Google, Facebook, Apple, SAP, Oracle, etc.</p>
<p>Até a pouco tempo Rust era mantido pela Mozilla (desenvolvedora do Firefox),
mas agora existe a <em>Rust Foundation</em>, que funciona independente, sendo patrocinada por:
<strong>AWS (Amazon), Google, Facebook, Huawei, Microsoft e Mozilla</strong>.</p>
<p><img src="image/rust-sponsors.png" alt="Rust sponsors" />
Estas empresas, além de manter a fundação financeiramente, também mantém seus próprios times para trabalhar no compilador.
Então são 6 grandes empresas pagando salários de programadores para trabalharem focados no Rust. Além destas, outras empresas
menores fazem o mesmo e vários outros programadores contribuem de forma independente.
Isso resulta que hoje <strong>há muito mais programadores trabalhando no Rust do que no Java</strong> (900 contra 200, consultando <em>commits</em> dos últimos meses).</p>
<p>A <em>Rust Foundation</em> foi criada somente no início de 2021,
então o fruto do envolvimento das grandes empresas ainda está por aparecer, por isso há uma grande expectativa da linguagem
crescer ainda mais em recursos, adoção e ecossistema.</p>
<h2 id="programar-em-rust-é-muito-legal"><a class="header" href="#programar-em-rust-é-muito-legal">Programar em Rust é muito legal</a></h2>
<p>Ferris, mascote do Rust:</p>
<p><img src="image/rust-ferris.png" alt="Rust ferris" /></p>
<p>Por cinco anos consecutivos <strong>Rust é considerada a linguagem mais amada do mundo</strong>, segundo pesquisa do <em>Stackoverflow</em>.
Apesar de ter uma curva de aprendizado maior que outras linguagens atuais, geralmente acaba conquistando
o programador principalmente pela sua sintaxe moderna e característica de gerar programas mais seguros.</p>
<p>O comportamento do compilador é muito amigável, geralmente dá dicas do que podemos estar errando e
como podemos resolver. Por exemplo, quando erramos o nome de uma variável ele sugere outras com nomes semelhantes.</p>
<p>A inferência de tipos é muito poderosa, graças ao seu <em>Bidirectional Typechecking</em>.
Muitas vezes não precisamos declarar o tipo das variáveis e ficamos com a impressão que estamos
programando em uma linguagem dinamicamente tipada,
entretanto sem correr o risco de ter seus possível erros.</p>
<p>Por se relativamente nova, conseguiu se adaptar muito bem a editores modernos tal como VSCode,
onde possui um <em>language server</em> com muitos recursos.</p>
<h2 id="Ótima-documentação-e-comunidade-vibrante"><a class="header" href="#Ótima-documentação-e-comunidade-vibrante">Ótima documentação e comunidade vibrante</a></h2>
<p>Existe muita fonte de informação sobre Rust. Esses são os principais:</p>
<p>Aprender:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Learn book oficial</a></li>
<li><a href="https://docs.microsoft.com/en-us/learn/paths/rust-first-steps/">Take your first steps with Rust (oficial Microsoft)</a></li>
<li><a href="https://tourofrust.com/">Tour of Rust</a></li>
<li><a href="https://dhghomon.github.io/easy_rust/">Easy Rust</a></li>
<li><a href="https://stevedonovan.github.io/rust-gentle-intro/">Rust Gentle</a></li>
<li><a href="https://fasterthanli.me/articles/i-am-a-java-csharp-c-or-cplusplus-dev-time-to-do-some-rust">Artigo para programadores Java</a></li>
<li><a href="https://cheats.rs/">Rust Language Cheat Sheet</a></li>
</ul>
<p>Algoritmos de exemplo:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by example</a></li>
<li><a href="https://github.com/TheAlgorithms/Rust">The Algorithms</a></li>
<li><a href="https://rust-lang-nursery.github.io/rust-cookbook/intro.html">Cook Book</a></li>
</ul>
<p>Exercícios:</p>
<ul>
<li><a href="https://github.com/rust-lang/rustlings/">Rustlings</a></li>
<li><a href="https://exercism.io/my/tracks/rust">Exercism Rust Track</a></li>
</ul>
<p>Fóruns e ajuda:</p>
<ul>
<li><a href="https://users.rust-lang.org/">Fórum oficial</a></li>
<li><a href="https://www.reddit.com/r/learnrust/">Reddit Learn Rust</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a></li>
</ul>
<p>Novidades no mundo Rust:</p>
<ul>
<li><a href="https://www.reddit.com/r/rust/">Reddit Rust</a></li>
<li><a href="https://this-week-in-rust.org/">This Week in Rust</a></li>
</ul>
<p>Padrões sugeridos:</p>
<ul>
<li><a href="https://rust-unofficial.github.io/patterns/">Design patterns in Rust</a></li>
<li><a href="https://nnethercote.github.io/perf-book/">Performance book</a></li>
<li><a href="https://doc.rust-lang.org/1.0.0/style/">Guia de estilo</a></li>
<li><a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a></li>
</ul>
<h1 id="criar-e-executar-projeto"><a class="header" href="#criar-e-executar-projeto">Criar e executar projeto</a></h1>
<p><code>Cargo</code> é o gerenciador de projetos do Rust. É o equivalente ao Maven do Java.
Usamos ele para criar projeto, compilar, executar, etc.</p>
<p>Para criar projeto:</p>
<pre><code class="language-terminal">cargo new treinamento-rust
</code></pre>
<p>Será criado um diretório <code>treinamento-rust</code>. Vamos entrar nele:</p>
<pre><code class="language-terminal">cd treinamento-rust
</code></pre>
<p>Esta é a estrutura de diretório quem contém o projeto:</p>
<pre><code class="language-terminal">treinamento-rust/
|
|-src/
|   |
|    `-main.rs
|
|-.gitignore
|
`-Cargo.toml
</code></pre>
<p>O arquivo <code>Cargo.toml</code> contém configurações do projeto, principalmente dependências.</p>
<p>Por padrão Rust vem com uma biblioteca nativa bem enxuta, então é comum adicionarmos dependências.
Outro motivo de ter algumas bibliotecas desacopladas do compilador é que podemos ficar com uma versão estável do compilador e pode atualizar as bibliotecas de forma independente.</p>
<p>O arquivo <code>src/main.rs</code> contém o código fonte principal, com um &quot;Hello World&quot;:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Para executar o programa:</p>
<pre><code class="language-terminal">cargo run
</code></pre>
<p>Aparecerá como resultado:</p>
<pre><code class="language-terminal">   Compiling treinamento-rust v0.1.0 (C:\Users\Vanius\Documents\rust\treinamento-rust)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target\debug\treinamento-rust.exe`
Hello, world!
</code></pre>
<p>O compilador algumas informações da compilação e por fim o resultado do programa com a frase <code>Hello, world!</code></p>
<p>Podemos executar o programa para exibir somente o resultado, através de :</p>
<pre><code class="language-terminal">cargo run -q
</code></pre>
<p>Para compilar o programa devemos fazer:</p>
<pre><code class="language-terminal">cargo build
</code></pre>
<p>Esse comando gera o binário executável dentro do diretório <code>target/debug/</code></p>
<p>Para compilar o programa e gerar o binário otimizado final (bem mais rápido):</p>
<pre><code class="language-terminal">cargo build --release
</code></pre>
<p>Para executar testes unitários:</p>
<pre><code class="language-terminal">cargo test
</code></pre>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h2>
<p>Como vimos no capítulo anterior, criamos o arquivo <code>src/main.rs</code>, que contém o &quot;Hello, world!&quot;:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Nesse exemplo já vemos algumas características do Rust, que é muito comum a outras linguagens conhecidas.</p>
<p>O prefixo <code>fn</code> define o uma função, que é um bloco que contém um conjunto de comandos.</p>
<p>As funções permitem parâmetros através de parênteses <code>()</code>. Quando não possui parâmetros deve informá-los igualmente.</p>
<p>Chaves <code>{}</code> são delimitadores de blocos.</p>
<p>Todo comando termina com ponto-e-vírgula <code>;</code>.</p>
<p>Aspas duplas <code>&quot;&quot;</code> delimitam String.</p>
<p>O comando <code>println!</code> exibe a String na tela.</p>
<p>O sinal de exclamação <code>!</code> significa que o comando é uma &quot;macro&quot;, que é um recurso de &quot;meta programação&quot; do Rust. As macros são comandos que são expandidos em tempo de compilação, como se fosse um pré-compilador embutido na linguagem. O interessante desse mecanismo é que funciona como um comando real para o programador.</p>
<h2 id="executar-programa"><a class="header" href="#executar-programa">Executar programa</a></h2>
<p>Como falamos anteriormente podemos executar o programa pela linha de comando <code>cargo run</code>.</p>
<p>O <em>language server</em> do Rust permite o recurso de executar o programa de dentro do editor VSCode.
Se tudo estiver certo acima do <code>main</code> deve ter um ícone para executar e outro para debugar.</p>
<h3 id="instalação-de-programa"><a class="header" href="#instalação-de-programa">Instalação de programa</a></h3>
<p>Quando instalamos o Rust ele insere no <code>PATH</code> o diretório <code>%USERPROFILE%\\.cargo\\bin</code> (ou <code>C:\\Users\\%USERNAME%\\.cargo\\bin</code>).</p>
<p>Nesse diretório também serve para conter os programas que querermos que seja acessível de qualquer diretório.</p>
<p>Para que o nosso programa seja compilado e o executável seja copiado para lá deve executar o comando:</p>
<pre><code class="language-terminal">cargo install --path .
</code></pre>
<h2 id="convenção-de-nomes"><a class="header" href="#convenção-de-nomes">Convenção de nomes</a></h2>
<p>Variáveis, funções, módulos, métodos devem ter formato <code>snake_case</code>.</p>
<p>Constantes e variáveis estáticas devem ter formato <code>SCREAMING_SNAKE_CASE</code>.</p>
<p>Classes, tipo, enumerados devem ter formato <code>CamelCase</code>.</p>
<p>Mais detalhes em: <a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Convenção de nomes padrão</a></p>
<h2 id="padrões-de-comentários"><a class="header" href="#padrões-de-comentários">Padrões de comentários</a></h2>
<p>Para definir comentário é bastante semelhante a outras linguagens.</p>
<p>Comentário de linha <code>//</code></p>
<p>Comentário de bloco <code>/* */</code></p>
<p>Comentário para documento <code>///</code></p>
<p>Mais detalhes em: <a href="https://doc.rust-lang.org/reference/comments.html">Padrões de comentários</a></p>
<h3 id="declarar-variável"><a class="header" href="#declarar-variável">Declarar variável</a></h3>
<p>Para declarar uma variável usamos o comando <code>let</code>. O sinal de <code>=</code> faz a atribuição do valor inicial.</p>
<p>O comando <code>println!</code> permite exibir o conteúdo fazendo substituição das chaves no texto.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let i = 1;
println!(&quot;i = {}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<h3 id="interpolação"><a class="header" href="#interpolação">Interpolação</a></h3>
<p>Como já foi explicado, Rust vem com uma biblioteca padrão bem reduzida.
Para permitir interpolação devemos inserir o <code>ifmt</code> no <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
ifmt = &quot;0.3.3&quot;
</code></pre>
<p>Essa dependência inclui o comando <code>iprintln!</code> entre outros.
Para fazer o <code>import</code> dessa biblioteca basta pressionar <code>ctrl + .</code> em cima da palavra <code>iprintln!</code> e selecionar no menu <code>Import ifmt::iprintln</code>. Será inserida linha <code>use ifmt::iformat;</code> no topo do fonte.</p>
<p>Então agora podemos fazer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let i = 1;
iprintln!(&quot;i = {i}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Esse recurso é extremamente poderoso, pois a interpolação é resolvida em tempo de compilação,
então mesmo estando dentro de uma <code>string</code> o compilador avisará se a variável não existir.
Também podem ser usadas funções com interpolação.</p>
<h3 id="tipo-explícito"><a class="header" href="#tipo-explícito">Tipo explícito</a></h3>
<p>Observe que no exemplo acima não definimos o tipo da variável.</p>
<p>O tipo acabou sendo inferido implicitamente, ou seja, o compilador utilizou o tipo do valor que está sendo associado.</p>
<p>A inferência de tipo do Rust é uma das suas principais característica. Muitas vezes temos a impressão que estamos trabalhando numa linguagem dinamicamente tipada.</p>
<p>Podemos explicitar o tipo, por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let i: i32 = 1;
println!(&quot;i = {}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<p>O <code>i32</code> define uma variável numérica inteira de 32 bits.</p>
<p>A linha acima pode declarar como <code>let i = 1;</code>.</p>
<p>A seguir vamos ver outros tipos inteiros.</p>
<h3 id="tipos-numéricos-inteiros"><a class="header" href="#tipos-numéricos-inteiros">Tipos numéricos inteiros</a></h3>
<p>Rust permite inteiros com sinal ou sem sinal, e também com diferente comprimentos:</p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<h3 id="atribuição-de-variáveis"><a class="header" href="#atribuição-de-variáveis">Atribuição de variáveis</a></h3>
<p>Rust traz o moderno conceito sobre imutabilidade, onde por padrão as variáveis não podem ser alteradas depois que seu valor inicial foi definido.</p>
<p>Para permitir a variável ser alteradas devemos informar a palavra <code>mut</code> após o <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut i = 0;
println!(&quot;i = {}&quot;, i);
i = 1;
println!(&quot;i = {}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<h3 id="constantes"><a class="header" href="#constantes">Constantes</a></h3>
<p>Para definir constante utilizamos a palavra <code>const</code> e termos que definir o tipo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>const MAX_VALUE: u32 = 100;
let i = MAX_VALUE;
println!(&quot;max value = {}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<p>Observações:</p>
<p>Inicialmente pode parecer que <code>let</code> sem <code>mut</code> funciona como <code>const</code>, mas são diferente.
As variáveis imutáveis, por mais que não possamos alterar, acabam alocando memória, diferente
das constantes, que são expressas em tempo de compilação.</p>
<h3 id="operações-aritméticas"><a class="header" href="#operações-aritméticas">Operações aritméticas</a></h3>
<p>As operações aritméticas são iguais a outras linguagens. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut i = 0;
println!(&quot;{}&quot;, i);
i = 2 + 5;
println!(&quot;{}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<p>Para incrementar variáveis podemos utilizar <code>+=</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut i = 0;
i += 1;
println!(&quot;i = {}&quot;, f);
<span class="boring">}
</span></code></pre></pre>
<h3 id="tipos-pontos-flutuante"><a class="header" href="#tipos-pontos-flutuante">Tipos pontos flutuante</a></h3>
<p>Existem os tipos <code>f32</code> e <code>f64</code>. Para indicar um número como ponto flutuante devemos informar o ponto decimal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let f = 1.0;
println!(&quot;f = {}&quot;, f);
<span class="boring">}
</span></code></pre></pre>
<h3 id="type-cast"><a class="header" href="#type-cast">Type cast</a></h3>
<p>Conversões <em>type conversion</em> (<em>casting</em>) podem ser feitas pela palavra <code>as</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let decimal = 65.4321_f32;

    // Error! No implicit conversion
    let integer: u8 = decimal;
    // FIXME ^ Comment out this line

    // Explicit conversion
    let integer = decimal as u8;
    let character = integer as char;
</code></pre></pre>
<h3 id="tipo-boolean"><a class="header" href="#tipo-boolean">Tipo <em>boolean</em></a></h3>
<p>Tipos lógicos <code>bool</code> possuem o valor <code>false</code> e <code>true</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let result = false;
println!(&quot;result = {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<h3 id="operações-lógicas"><a class="header" href="#operações-lógicas">Operações lógicas</a></h3>
<p>As operações lógicas também são iguais a outras linguagens. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut result = false;
println!(&quot;{}&quot;, result);
result = result == true;
println!(&quot;{}&quot;, result);
result = result || true;
println!(&quot;{}&quot;, result);
result = result &amp;&amp; true;
println!(&quot;{}&quot;, result);
result = result != true;
println!(&quot;{}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<h3 id="vetor-array"><a class="header" href="#vetor-array">Vetor (<em>Array</em>)</a></h3>
<p>O tipo <em>array</em> é semelhante a outras linguagens, os caracteres <code>[]</code>
indicam que se trata de vetor e os elementos são delimitados por vírgula:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
println!(&quot;a = {:?}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<p>Observe que no <code>println!</code> usamos a substituição <code>{:?}</code> ao invés de <code>{}</code>.
Isso por que o vetor não implementa a interface <code>Display</code>,
que seria equivalente ao Java a um objeto sobre-escrever o método <code>toString</code>.
Veremos mais detalhes disso em outro capítulo.</p>
<p>A tipagem explícita é <code>[T; n]</code>, onde <code>T</code> é tipo e <code>n</code> é o tamanho:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
println!(&quot;a = {:?}&quot;, a);
<span class="boring">}
</span></code></pre></pre>
<p><em>array</em> é um vetor estático, ou seja, não podemos alterá-lo.
Para alterar existe outra estrutura de dados chamada <code>Vec</code> (que veremos em outro capítulo).
Semelhante como no Java, onde existe <em>array</em> e <code>ArrayList</code>.</p>
<h3 id="tipo-range"><a class="header" href="#tipo-range">Tipo <em>range</em></a></h3>
<p>Para representar um <em>range</em> (faixa) devemos usar a notação <em>início..fim</em>, sendo que o fim não é incluído.
Ou seja, 1 a 10 é representado com <code>1..11</code>. Essa característica existe para facilitar percorrer vetor onde o tamanho é indicado no fim, tal como <code>0..lista.len()</code>. Se quer que o fim seja incluído, deve usar o sinal de <code>=</code>, por exemplo <code>1..=10</code>.</p>
<p>Exemplos:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let r = 0..10;

let a = 9;
let b = 10;
let f = a..b;
<span class="boring">}
</span></code></pre></pre>
<p>O <em>range</em> também é utilizado para trabalhar com <em>slice</em> (fatia) de vetor. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let arr = [0, 1, 2, 3, 4];
assert_eq!(arr[ ..  ], [0,1,2,3,4]);
assert_eq!(arr[ .. 3], [0,1,2    ]);
assert_eq!(arr[ ..=3], [0,1,2,3  ]);
assert_eq!(arr[1..  ], [  1,2,3,4]);
assert_eq!(arr[1.. 3], [  1,2    ]);
assert_eq!(arr[1..=3], [  1,2,3  ]);
<span class="boring">}
</span></code></pre></pre>
<p>Em outro capítulo veremos que podemos usar <em>ranges</em> no comando <code>for</code>.</p>
<h3 id="tipo-tupla"><a class="header" href="#tipo-tupla">Tipo tupla</a></h3>
<p>As tuplas são coleções de tipos diferentes, construídas no formato <code>(T1, T2, T3, ...)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let t = (1u32, false);
println!(&quot;{:?}&quot;, t);
<span class="boring">}
</span></code></pre></pre>
<p>Podemos fazer a desconstrução das tuplas pela sintaxe <code>let (a, b, ...) =</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let t = (1u32, false);
let (i, b) = t;
println!(&quot;{} {}&quot;, i, b);
<span class="boring">}
</span></code></pre></pre>
<p>É possível acessarmos os valores através do índice pela sintaxe <code>.i</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let t = (1u32, false);
println!(&quot;{} {}&quot;, t.0, t.1);
<span class="boring">}
</span></code></pre></pre>
<h3 id="variável-place-holder"><a class="header" href="#variável-place-holder">Variável <em>place holder</em></a></h3>
<p>Em algumas situações queremos ignorar parte de uma tupla, porém por padrão o compilar
emite alerta se uma variável não for utilizada.
Podemos imaginar o <em>place holder</em> como sendo o <code>filler</code> do COBOL,
serve apenas preencher uma necessidade do compilador.
Exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let t = (1u32, false);
let (i, _) = t;
println!(&quot;{}&quot;, i);
<span class="boring">}
</span></code></pre></pre>
<p>As varáveis <code>foo</code> na verdade podem até ter nome, iniciando com underscore, tal como <code>_status</code>.</p>
<h3 id="tipo-caractere"><a class="header" href="#tipo-caractere">Tipo caractere</a></h3>
<p>Tipos <code>char</code> são definidos com aspas simples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let c = '*';
println!(&quot;c = {}&quot;, c);
<span class="boring">}
</span></code></pre></pre>
<h3 id="tipo-texto"><a class="header" href="#tipo-texto">Tipo texto</a></h3>
<p>Existem dois tipos de String: <code>String</code> e <code>&amp;str</code>, que possuem as seguintes diferenças:</p>
<ul>
<li><code>String</code> é uma <em>string</em> dinâmica alocada na memória <em>heap</em>, podendo aumentar de tamanho.</li>
<li><code>&amp;str</code> é uma referência em algum lugar na memória (<em>heap</em> ou <em>stack</em>) de uma cadeia de caracteres, não pode mudar de tamanho. Também pode ser chamado de <em>slice</em>.</li>
</ul>
<p>Para facilitar entendimento, podemos fazer um comparativo ao Java, com os tipos <code>String</code> e <code>StringBuilder</code>.</p>
<p>Quando declaramos uma literal é assumido o tipo <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = &quot;Rech Informática&quot;;
println!(&quot;s = {}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p>Vamos ver um exemplo do tipo <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s = String::from(&quot;Rech Informática&quot;);
println!(&quot;s = {}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p>Nesse exemplo já vemos mais algumas características do Rust. Os dois sinais de <code>:</code> significa que é delimitador de uma função estática da classe.
No caso <code>from</code> é um construtor da classe.
Um ponto <code>.</code> significa um delimitador de método dinâmico.</p>
<p>Podemos converter um <em>slice String</em> <code>&amp;str</code> para <code>String</code> através do método <code>to_string</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let hello = &quot;Hello&quot;.to_string();
println!(&quot;hello = {}&quot;, hello);
<span class="boring">}
</span></code></pre></pre>
<p>Podemos converter uma <code>String</code> para <code>&amp;str</code>, definindo o caractere <code>&amp;</code> antes do String, que funciona como uma referência:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s: &amp;str = &amp;String::from(&quot;Rech Informática&quot;);
println!(&quot;s = {}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p>Por causa disso para definirmos funções geralmente utilizaremos o <code>&amp;str</code> como tipo de parâmetros, por ser mais compatível e permitir literais.</p>
<blockquote>
<p>É natural haver uma dificuldade inicial para lidar e entender os dois tipos de <em>String</em>,
mas como foi dito no capítulo de introdução: se compilar então você está fazendo certo,
você não terá erros ou comportamentos inesperados.</p>
</blockquote>
<h2 id="concatenação-de-string"><a class="header" href="#concatenação-de-string">Concatenação de string</a></h2>
<p>Rust permite a concatenação de String com o caractere <code>+</code>, mas deve ter o formato:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String + &amp;String + &amp;String;
<span class="boring">}
</span></code></pre></pre>
<p>Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn test_concat() {
</span>let nome = &quot;Rech&quot;.to_string();
let segundo_nome = &quot;Informática&quot;.to_string();
let result: String = nome + &amp;segundo_nome;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Na concatenação não é possível usar <code>&amp;str</code> diretamente,
há necessidade de converter para String.</p>
<p>Existem várias possibilidades para fazer concatenação.
Uma das possíbilidades é usar o método <code>push_str</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Rech&quot;);
s.push_str(&quot; &quot;);
s.push_str(&quot;Informática&quot;);
println!(&quot;s = {}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><strong>Outra forma bem comum, e a mais recomendada, é através da macro <code>format!</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn method_1() {
</span>let hello = &quot;Hello&quot;;
let world = &quot;world&quot;;
let result = format!(&quot;{}, {}!&quot;, hello, world);
assert_eq!(&quot;Hello, world!&quot;, result);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>A dependência <code>ifmt</code> também declara a macro <code>iformat!</code>, que permite fazermos uma concatenação bastante elegante:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn method_2() {
</span><span class="boring">   use ifmt::iformat;
</span>let hello = &quot;Hello&quot;;
let world = &quot;world&quot;;
let result = iformat!(&quot;{hello}, {world}!&quot;);
iprintln!(&quot;{result}&quot;);
assert_eq!(&quot;Hello, world!&quot;, result);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Podemos declarar um <code>array</code> e fazer <code>concat</code> ao final:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn method_3() {
</span>let world = &quot;world&quot;;
let result = [&quot;Hello&quot;, &quot;, &quot;, world, &quot;!&quot;].concat();
assert_eq!(&quot;Hello, world!&quot;, result);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Ou também fazer um <code>join</code> informando um delimitador:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn method_4() {
</span>let world = &quot;world&quot;;
let result = [&quot;Hello&quot;, world, &quot;!&quot;].join(&quot; &quot;);
assert_eq!(&quot;Hello world !&quot;, result);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>A macro <code>concat!</code> permite concatenação, mas apenas de literais, não permite informar variáveis como na <code>format!</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn method_5() {
</span>let result = concat!(&quot;Hello&quot;, &quot;, &quot;, &quot;world&quot;, &quot;!&quot;);
assert_eq!(&quot;Hello, world!&quot;, result);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="substring"><a class="header" href="#substring">Substring</a></h3>
<p>Existe várias maneiras para obter <em>substring</em> de uma outra <em>string</em>.
Uma delas é trabalhar com <em>range</em> inicial e final, por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let valor = &amp;&quot;CAMPO=valor&quot;[6..11];
println!(&quot;{}&quot;, valor);
<span class="boring">}
</span></code></pre></pre>
<p>O <em>range</em> deve ser informado números do tipo <code>usize</code>, então eventualmente pode ser necessário fazer
<em>type cast</em> tal como <code>i as usize</code>.</p>
<p>Outra forma é converter a <em>string</em> para vetor de <em>chars</em> e obter os elementos desejados,
ao final converter para <em>string</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let valor: String = &quot;CAMPO=valor&quot;.chars().skip(6).take(5).collect();
println!(&quot;{}&quot;, valor);
<span class="boring">}
</span></code></pre></pre>
<p>Uma situação muito como é obter a <em>string</em> a partir um prefixo, para isso existe o método <code>strip_prefix</code>
que é muito útil:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let valor = &quot;CAMPO=valor&quot;.strip_prefix(&quot;CAMPO=&quot;).unwrap();
println!(&quot;{}&quot;, valor);
<span class="boring">}
</span></code></pre></pre>
<h3 id="converter-tipos-para-string"><a class="header" href="#converter-tipos-para-string">Converter tipos para String</a></h3>
<p>Todos tipo possuem o método <code>to_string</code>, por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let x: u32 = 10;
let s: String = x.to_string();
println!(&quot;{}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<h3 id="fazer-parse-de-string-para-numérico"><a class="header" href="#fazer-parse-de-string-para-numérico">Fazer <em>parse</em> de String para numérico</a></h3>
<p>Os tipos <code>&amp;str</code> e <code>String</code> possuem o método <code>parse</code> que faz a conversão para outro tipo destino.
Como essa função pode falhar, então ela retorna um <code>Result</code> que veremos em outro capítulo.
Por enquanto vamos obter o valor através de seu método <code>unwrap</code>, <code>expect</code> (que permite passar uma mensagem).</p>
<p>Exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>O exemplo acima fazia a conversão de acordo com o tipo explícito da variável destino.
Porém é possível informar o tipo como um parâmetro <em>generic</em> no método <code>parse</code>. Esse tipo sintaxe usando <code>::&lt;&gt;</code> é conhecido por <em>turbo fish</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let my_int = my_string.parse::&lt;i32&gt;().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="escape-e-caracteres-especiais-em-string"><a class="header" href="#escape-e-caracteres-especiais-em-string">Escape e caracteres especiais em String</a></h3>
<p>Como em muitas linguagens é possível escapar caracteres especiais com <code>\</code>, tal como quebra de linha por <code>\n</code>.
É possível definir caracteres ASCII por <code>\xXX</code> e UTF-8 por <code>\u{XXXX}</code>.
Também é possível quebrar a linha com enter e continuar a linha com <code>\</code> ao final.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);
<span class="boring">
</span>    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );

    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>As vezes para pode atrapalhar ficar sempre escapando os caracteres tipo <code>&quot;F:\\SIGER\\21.10\\fon&quot;</code>.
Nesses casos podemos usar as <em>raw strings</em> com <code>r&quot;</code> e <code>r#&quot;</code> (para considerar <code>&quot;</code> como <em>raw</em>):</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<h3 id="declarar-funções"><a class="header" href="#declarar-funções">Declarar funções</a></h3>
<p>Para declarar funções e executá-las fazemos semelhante a outras linguagens:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<h3 id="passagem-de-parâmetros"><a class="header" href="#passagem-de-parâmetros">Passagem de parâmetros</a></h3>
<p>Passar parâmetros também é familiar:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<h3 id="todo-bloco-pode-ser-uma-expressão"><a class="header" href="#todo-bloco-pode-ser-uma-expressão">Todo bloco pode ser uma expressão</a></h3>
<p>Rust possui uma interessante característica do paradigma funcional que todo bloco pode funcionar como uma expressão,
ou seja, pode retornar um valor.
Para indicar um retorno basta a última linha não conter <code>;</code>. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let v = {
    let a = 1;
    let b = 2;
    a + b
};
println!(&quot;from block: {}&quot;, v);
<span class="boring">}
</span></code></pre></pre>
<p>Vale observar que esse tipo de sintaxe a linguagem Java implementou superficialmente, apenas funciona em <em>lambdas</em>, tal como <code>.filter(emp -&gt; emp.age &lt; age)</code>.</p>
<p>Este recurso pode ser usado no controle de fluxo de outras operações que veremos em outro capítulo.</p>
<h3 id="função-com-retorno"><a class="header" href="#função-com-retorno">Função com retorno</a></h3>
<p>Para declarar uma função indicamos o tipo de retorno por <code>-&gt;</code> e seguimos a lógica da última linha não ter <code>;</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = five();
    println!(&quot;The value of x is: {}&quot;, x);
}

fn five() -&gt; i32 {
    5
}
</code></pre></pre>
<p>Também podemos retornar o valor de função a partir do comando <code>return</code>, nesse caso colocamos o <code>;</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = 10;

    println!(&quot;a = {}&quot;, foo(a));
}

fn foo(a: i8) -&gt; i8 {
    if a &gt; 0 {
        return 5;
    };
    a + 1
}
</code></pre></pre>
<h3 id="atributos-de-itens"><a class="header" href="#atributos-de-itens">Atributos de itens</a></h3>
<p>Os itens (funções, <em>enums</em>, <em>structs</em>, etc) podem ter definido <em>attributes</em>,
onde associa um meta-dado ou altera o comportamento. Possui o formato <code>#[Attr]</code> ou <code>#![Attr]</code>.
Funcionam parecido como as <em>annotations</em> do Java.</p>
<p>Vamos ver um exemplo para condicionar funções por compilação da plataforma:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = &quot;windows&quot;)]
fn list_mapped_drive() {
}

#[cfg(not(target_os = &quot;linux&quot;))]
fn distro_linux() {
}
<span class="boring">}
</span></code></pre></pre>
<p>Esse atributo acima também pode ser definido em bloco de código.</p>
<h3 id="função-de-teste"><a class="header" href="#função-de-teste">Função de teste</a></h3>
<p>Criar funções de testes unitários em Rust é bem prático.
Por padrão as funções de testes são declaradas ao fim no mesmo fonte.
Isso facilita pois não precisamos ficar alternando entre vários fontes.</p>
<p>Para definir função de teste unitários basta declarar o atributo <code>#[test]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test() {
}
<span class="boring">}
</span></code></pre></pre>
<p>A extensão do VSCode deve exibir um ícone de <em>play</em> acima da função.</p>
<p>Essa forma de atribuição por <code>#[xxx]</code></p>
<p>Observe que o <em>language server</em> do Rust disponibilizou um <em>play</em> para executar a função de teste.
Esse recurso é muito prático enquanto estamos prototificando uma rotina, pois podemos declarar
a função de testar para executar a nossa função no mesmo fonte.</p>
<h3 id="funções-de-assertação"><a class="header" href="#funções-de-assertação">Funções de assertação:</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(true);
let a = 1;
let b = 1;
let c = 2;
assert_eq!(a, b);
assert_ne!(a, c);
<span class="boring">}
</span></code></pre></pre>
<h3 id="definir-pacote-de-teste"><a class="header" href="#definir-pacote-de-teste">Definir pacote de teste</a></h3>
<p>O ideal é isolar as funções de testes em um módulo, que pode ser declarado ao final do código fonte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test() {
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A linha <code>use super::*</code> serve par tornar as funções do fonte visíveis para o módulo de teste.</p>
<p>Para executar os testes devemos rodar o comando do cargo:</p>
<pre><code class="language-terminal">cargo test
</code></pre>
<h3 id="criar-lib-biblioteca"><a class="header" href="#criar-lib-biblioteca">Criar lib (biblioteca)</a></h3>
<p>As <em>libs</em> são projetos que não geram executável, que podem declarar itens para serem reaproveitados em outros projetos.</p>
<p>Vamos criar uma <em>lib</em> chamada `my-lib para usarmos no nosso projeto, onde temos que criá-lo no mesmo diretório:</p>
<pre><code class="language-terminal">cd ..
cargo new my-lib --lib
cd my-lib
code .
</code></pre>
<p>A principal diferença é que ao invés do <code>main.rs</code> tempos o <code>lib.rs</code>.</p>
<p>Nesse fonte iremos definir as nossas funções. Para os itens serem visíveis externamente temos que definir o prefixo <code>pub</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn double(num: i32) -&gt; i32 {
    num * 2
}
<span class="boring">}
</span></code></pre></pre>
<p>No nosso projeto podemos incluir a dependência com via relativa de diretório:</p>
<pre><code class="language-toml">[dependencies]
my-lib = { path = &quot;../my-lib&quot; }
</code></pre>
<p>No fonte, devemos fazer o <em>import</em> com <code>use</code>, onde definimos o nome da <em>lib</em> e o nome da função que queremos importar.
Observe que no nome da <em>lib</em> ao invés de <code>-</code> (hífen) devemos trocar por <code>_</code> (underline) e que usamos delimitador de
pacote e função com <code>::</code>:</p>
<pre><pre class="playground"><code class="language-rust">use my_lib::double;
fn main() {
    let d = double(1);
    println!(&quot;{}&quot;, d);
}
</code></pre></pre>
<h3 id="documentação"><a class="header" href="#documentação">Documentação</a></h3>
<p>No itens de Rust (funções, struct, enuns, etc) podemos definir comentários no código fonte que resultarão em documentos.
Para isso devemos definir comentário com três barras <code>///</code></p>
<p>Para criar um trecho com código Rust devemos declarar um bloco com <code>```rust</code> e terminar com <code>```</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Retorna o dobro
/// Exemplo:
/// ```rust
/// use my_lib::double;
/// assert_eq!(double(1u32), 2u32);
/// ```
pub fn double(num: u32) -&gt; u32 {
    num * 2
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Observe que o código declarado na documentação pode ser executado, não é apenas um texto ilustrativo.
Isso garante que a documentação estará sempre condizente com a implementação.
E outra coisa bastante interessante, esse código é executado com o <code>cargo test</code>, ou seja,
esse código funciona como documentação e teste unitário, evitando duplicidade.</p>
</blockquote>
<p>A documentação com código executável funciona apenas para <em>libs</em>,
mas está sendo estudado para funcionar em projetos executáveis também.</p>
<p>Para gerar o documento:</p>
<pre><code>cargo doc
</code></pre>
<p>Os documentos html serão gerados no diretório <code>target/doc</code>.</p>
<p>Para gerar o documento e abrir o navegador devemos executar:</p>
<pre><code>cargo doc --open
</code></pre>
<p>Existe também o comando <code>rustdoc</code> para gerar doc de um arquivo avulso.
Por exemplo, para gerar o <code>docs/doc/README.html</code> a partir do <code>README.md</code></p>
<pre><code>rustdoc README.md
</code></pre>
<h2 id="controle-de-fluxo"><a class="header" href="#controle-de-fluxo">Controle de fluxo</a></h2>
<p>Neste capítulo vamos ver as principais estruturas de controle de fluxo</p>
<h3 id="if"><a class="header" href="#if">if</a></h3>
<p>A estrutura <code>if</code> e <code>else</code> funcionam semelhante como em outras linguagens:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let number = 3;

if number &lt; 5 {
    println!(&quot;condition was true&quot;);
} else {
    println!(&quot;condition was false&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>É obrigatório definir o bloco com chaves <code>{}</code>.</p>
<h3 id="operação-ternária"><a class="header" href="#operação-ternária">Operação ternária</a></h3>
<p>Lembre da característica de Rust que todo bloco pode funcionar como uma expressão.
A operação ternária acaba sendo o retorno do bloco <code>if</code> ou <code>else</code>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let condition = true;
let number = if condition { 5 } else { 6 };

println!(&quot;The value of number is: {}&quot;, number);

let compare = if 12 * 15 &gt; 150 {
    &quot;Bigger&quot;
} else {
    &quot;Smaller&quot;
};

println!(&quot;The value of number is: {}&quot;, compare);
<span class="boring">}
</span></code></pre></pre>
<p>Observe Para o exemplo acima funcionar o bloco do <em>if</em> e o bloco do <em>else</em> devem retornar o mesmo tipo.</p>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<p>Laço de repetição condicional:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut number = 3;

while number != 0 {
    println!(&quot;{}!&quot;, number);

    number -= 1;
}

println!(&quot;LIFTOFF!!!&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<p>O <code>loop</code> é equivalente ao <code>while true</code> que possui a finalização condicionada. Pode definir um valor de retorno. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut counter = 0;

let result = loop {
    counter += 1;

    if counter == 10 {
        break counter * 2;
    }
};

println!(&quot;The result is {}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<p>O comando <code>break</code> interrompe a repetição do bloco e retorna um valor para o bloco.</p>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<p>Para percorrer um <code>iterator</code> podemos usar o comando <code>for</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = [10, 20, 30, 40, 50];

for element in a.iter() {
    println!(&quot;the value is: {}&quot;, element);
}
<span class="boring">}
</span></code></pre></pre>
<p>O método <code>iter</code> retorna um <em>iterator</em> a partir do <em>array</em>. Seria equivalente ao <code>Stream</code> do Java.
Veremos mais detalhes sobre <em>iterators</em> em outro capítulo.</p>
<p>O comando <code>for</code> também pode percorrer um <em>range</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>for i in 0..10 {
    println!(&quot;the value is: {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<p>A estrutura <code>match</code> é semelhante ao <code>switch</code> de outras linguagens:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let i = 5;
match i {
    0 =&gt; println!(&quot;zero&quot;),
    1 =&gt; println!(&quot;um&quot;),
    x =&gt; println!(&quot;inesperado {}&quot;, x).
}
<span class="boring">}
</span></code></pre></pre>
<p>Somente um bloco é executado de cada vez (não é necessário fazer um <code>break</code>). Cada bloco é chamado de <em>match arm</em>.</p>
<p>Outro comportamento do <code>match</code> é que ele é exaustivo, ou seja, devemos prever todas as possibilidades.
Isso é uma questão de segurança, para evitar erro do programador se deparar com uma situação inesperada.
No exemplo acima todas as possibilidades são previstas graças última condição,
onde a variável <code>x</code> (pode ter qualquer nome) captura o valor que não caiu nas condições acima.</p>
<p>Podemos testar diferentes valores pelo caractere <code>|</code> (ou). Para representar uma faixa de valores pode usar os caracteres <code>..</code>.
Poe exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let number = 13;
println!(&quot;Tell me about {}&quot;, number);
match number {
    1 =&gt; println!(&quot;One!&quot;),
    2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
    13..=19 =&gt; println!(&quot;A teen&quot;),
    x =&gt; println!(&quot;Ain't special: {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<p>Assim como outras estruturas, <code>match</code> pode funcionar como uma expressão que retorna um valor.
Isso permite construir códigos bem elegantes tal como:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let m = 1;
let month =
    match m {
        1 =&gt; &quot;jan&quot;,
        2 =&gt; &quot;feb&quot;,
        3 =&gt; &quot;mar&quot;,
        _ =&gt; &quot;other&quot;,
    };
println!(&quot;{}&quot;, month);
<span class="boring">}
</span></code></pre></pre>
<p>Quando match funciona como expressão todos os <code>arms</code> devem ter o mesmo retorno.
A exceção é caso forçarmos uma saída da função por <code>return</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let m = 1;
let month =
    match m {
        1 =&gt; &quot;jan&quot;,
        2 =&gt; &quot;feb&quot;,
        3 =&gt; &quot;mar&quot;,
        _ =&gt; return,
    };
println!(&quot;{}&quot;, month);
<span class="boring">}
</span></code></pre></pre>
<p>Nos exemplos acima cada <code>arm</code> retornava o valor numa única linha, porém o arm pode funcionar como
um bloco através das chaves, tendo a última linha como retorno:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let m = 1;
    let month =
        match m {
            1 =&gt; {
                println!(&quot;First month&quot;);
                &quot;jan&quot;
            },
            2 =&gt; &quot;feb&quot;,
            3 =&gt; &quot;mar&quot;,
            _ =&gt; &quot;other&quot;,
        };
    println!(&quot;{}&quot;, month);
}
</code></pre></pre>
<h2 id="rust-e-a-orientação-a-objetos"><a class="header" href="#rust-e-a-orientação-a-objetos">Rust e a Orientação a Objetos</a></h2>
<p>Existe uma discussão comum se Rust é orientado a objetos.</p>
<p>Antes de chegarmos a uma conclusão vamos revisar os principais princípios da programação Orientada a Objetos:</p>
<ul>
<li>
<p>Abstração</p>
<ul>
<li>Permitir um conjunto de propriedades e métodos funcionar sobre uma identidade</li>
<li>Essa identidade poder ser reutilizada (objeto) através uma prototipação (classe)</li>
</ul>
</li>
<li>
<p>Encapsulamento</p>
<ul>
<li>Indicar quais propriedades e métodos deseja tornar público</li>
</ul>
</li>
<li>
<p>Polimorfismo</p>
<ul>
<li>Generalizar objetos de diferentes implementações (classes)</li>
</ul>
</li>
<li>
<p>Herança</p>
<ul>
<li>Expandir subtipo de uma classe para outras em forma hierárquica, reaproveitando propriedades e métodos</li>
</ul>
</li>
</ul>
<p>Rust possui todas as características acima, exceto herança. Mas hoje em dia herança é considerado um <em>anti-pattern</em> que deve ser evitado. Ou seja, então teoricamente programar em Rust não fica muito distinto de um programa Java que segue as boas práticas de programação.</p>
<h2 id="boas-práticas-sobre-oo"><a class="header" href="#boas-práticas-sobre-oo">Boas práticas sobre OO</a></h2>
<p>Em geral a OO antiga diz que estado faz parte do objeto, onde seria um atributo.
Mas muitas vezes devem ser tratados como objetos distintos.</p>
<blockquote>
<p>A Orientação a Objetos tradicionalmente prega que objetos representam coisas.
Mas na verdade objetos <strong>operam</strong> sobre <strong>coisas</strong>.</p>
</blockquote>
<p>Ou seja:</p>
<blockquote>
<p>Operar =&gt; comportamento
Coisa =&gt; possui estado</p>
</blockquote>
<p>Podemos resumir esse tipo de pensamento da seguinte forma:</p>
<pre><code>objeto.operacao(estado)

estado = objeto.operacao()
</code></pre>
<p><em>objeto</em> é uma classe que dita comportamentos sobre outra classe de <em>estado</em>.</p>
<p>Ter essa distinção em mente nos ajuda a evitar de haver uso excessivo de mutabilidade (quando fazemos <code>set</code>).</p>
<h2 id="declarar-e-instanciar-objetos"><a class="header" href="#declarar-e-instanciar-objetos">Declarar e instanciar objetos</a></h2>
<p>Para declarar objetos em Rust usamos a sintaxe <code>struct</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    id: u32,
    name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Os campos são delimitados por vírgula <code>,</code>.</p>
<p>Para instanciar um objeto é usada uma sintaxe muito parecida com <em>Javascript</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    id: u32,
</span><span class="boring">    name: String,
</span><span class="boring">}
</span>fn main() {
    let user = User {
        id: 19,
        name: String::from(&quot;Vanius&quot;),
    };
    println!(&quot;User: {} {}&quot;, user.id, user.name);
}
</code></pre></pre>
<p>Observe que ao instanciar um objeto devemos informar o valor de todos os campos declarados.
Isso garante que nunca teremos um campo não inicializado.
Em outro capítulo iremos abordar como permitir um campo opcional.</p>
<h2 id="destruturar-struct-e-campos-restantes"><a class="header" href="#destruturar-struct-e-campos-restantes">Destruturar <em>struct</em> e &quot;campos restantes&quot;</a></h2>
<p>Podemos destruturar um <em>struct</em> em várias variáveis em uma única linha, semelhante como fazemos com tuplas.</p>
<pre><pre class="playground"><code class="language-rust">struct ThreeDPoint {
    x: f32,
    y: f32,
    z: f32
}

fn main() {
    let point_a: ThreeDPoint = ThreeDPoint { x: 0.3, y: 0.4, z: 0.5 };
    // É útil para obter vários campos em um única linha
    let ThreeDPoint { x: my_x, y: my_y, .. } = point_a;

    println!(&quot;x:{} y:{}&quot;, my_x, my_y);
}
</code></pre></pre>
<p>Quando queremos atribuir a partir de outro <em>struct</em> de mesmo tipo podemos usar dois pontos <code>..</code>
para pegar os restantes dos campos.</p>
<p>Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">struct ThreeDPoint {
    x: f32,
    y: f32,
    z: f32
}

fn main() {
    let point_a: ThreeDPoint = ThreeDPoint { x: 0.3, y: 0.4, z: 0.5 };

    // É útil quando queremos obter os campos restantes
    let point_b = ThreeDPoint { z: 0.5, ..point_a };

    println!(&quot;x:{} y:{} z:{}&quot;, point_b.x, point_b.y, point_b.z);
}
</code></pre></pre>
<h2 id="declarar-função-que-retorna-objeto"><a class="header" href="#declarar-função-que-retorna-objeto">Declarar função que retorna objeto</a></h2>
<p>Podemos criar uma função para retornar um objeto:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    id: u32,
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(id: u32, name: String) -&gt; User {
    User {
        id: id,
        name: name,
    }
}

fn main() {
    let user = build_user(19, String::from(&quot;Vanius&quot;));
    println!(&quot;User: {} {}&quot;, user.id, user.name);
}
</code></pre></pre>
<p>Se quisermos alterar o conteúdo temos que declarar como mutável:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    id: u32,
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn build_user(id: u32, name: String) -&gt; User {
</span><span class="boring">   User {
</span><span class="boring">       id: id,
</span><span class="boring">       name: name,
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span>    let mut user = build_user(19, String::from(&quot;Vanius&quot;));
    user.name = String::from(&quot;Vanius&quot;);
    println!(&quot;User: {} {}&quot;, user.id, user.name);
<span class="boring">}
</span></code></pre></pre>
<h2 id="declarar-método-estático"><a class="header" href="#declarar-método-estático">Declarar método estático</a></h2>
<p>Vamos supor que queremos tornar a função <code>build_user</code> como um construtor <code>new</code> do <em>struct</em>.
Para isso definimos uma nova sessão chamada <code>impl</code>, informamos qual o <em>struct</em> estamos implementando e declaramos nossa função:</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    id: u32,
    name: String,
}

impl User {
    fn new(id: u32, name: String) -&gt; User {
        User {
            id: id,
            name: name,
        }
    }
}

fn main() {
    let user = User::new(19, String::from(&quot;Vanius&quot;));
    println!(&quot;User: {} {}&quot;, user.id, user.name);
}
</code></pre></pre>
<p>Pode parecer estranho declarar funções num bloco separado das variáveis,
mas depois quando formos aprender sobre <em>Traits</em> (interfaces) iremos ver que faz sentido.</p>
<p>Perceba que <code>new</code> se transformou em uma função estática e
que acessamos funções estáticas pelos caracteres <code>::</code>.</p>
<p>Quando já estamos dentro do contexto do <em>struct</em> podemos acessar o seu nome pela palavra <code>Self</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">   id: u32,
</span><span class="boring">   name: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl User {
    fn new(id: u32, name: String) -&gt; Self {
        Self {
            id: id,
            name: name,
        }
    }
}
<span class="boring">fn main() {
</span><span class="boring">    let user = User::new(19, String::from(&quot;Vanius&quot;));
</span><span class="boring">    println!(&quot;User: {} {}&quot;, user.id, user.name);
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="declarar-método-dinâmico"><a class="header" href="#declarar-método-dinâmico">Declarar método dinâmico</a></h3>
<p>Para declarar um método dinâmico do objeto, devemos informar o primeiro parâmetro na função com <code>&amp;self</code>.</p>
<p>A partir da palavra <code>self</code> conseguimos acessar os campos do objeto de dentro do método,
semelhante como <code>this</code> em Java. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">   id: u32,
</span><span class="boring">   name: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl User {
    fn new(id: u32, name: String) -&gt; Self {
        Self {
            id: id,
            name: name,
        }
    }

    fn say_hello(&amp;self) {
        println!(&quot;Hi, I'm {}&quot;, self.name);
    }
}

fn main() {
    let user = User::new(19, String::from(&quot;Vanius&quot;));
    user.say_hello();
}
</code></pre></pre>
<blockquote>
<p>Podemos concluir que dentro do struct podemos acessar métodos estáticos com <code>Self::</code> e
métodos dinâmicos com <code>self.</code>.</p>
</blockquote>
<h3 id="método-criando-getter-e-setter"><a class="header" href="#método-criando-getter-e-setter">Método criando <em>getter</em> e <em>setter</em></a></h3>
<p>Em Rust os <em>getters</em> tem formato tal como <code>field(&amp;self) -&gt; T</code> e os <em>setters</em> formato <code>set_field(&amp;mut self, v: T)</code>. Para <em>getters</em> que retornam <em>bool</em> devemos usar <code>is_field(&amp;self) -&gt; bool</code>.</p>
<p>Observe que no <code>setter</code> é utilizado <code>&amp;mut self</code> ao invés de <code>&amp;self</code>.
Isso significa que o método <code>set_field</code> pode acessar os campos de forma mutável. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">   id: u32,
</span><span class="boring">   name: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl User {
    fn new(id: u32, name: String) -&gt; Self {
        Self {
            id: id,
            name: name,
        }
    }

    fn name(&amp;self) -&gt; String {
        self.name
    }

    fn set_name(&amp;mut self, name: String) {
        self.name = name;
    }
}

fn main() {
    // user_1 só permite ler campo, não é mutável
    let user_1 = User::new(19, String::from(&quot;Vanius&quot;));
    println!(&quot;user_1: {}&quot;, user_1.name());

    // user_2 permite ler e gravar campo, pois é mutável
    let mut user_2 = User::new(19, String::from(&quot;Vanius&quot;));
    user_2.set_name(&quot;Roberto&quot;);
    println!(&quot;user_2: {}&quot;, user_2.name());
}
</code></pre></pre>
<h3 id="enumerados"><a class="header" href="#enumerados">Enumerados</a></h3>
<p>No Rust os tipos enumerados possuem algumas possibilidades que outras linguagens não permitem.
Para definir um enumerado em Rust usamos a palavra <code>enum</code>.
No exemplo abaixo definimos o tipo de rede endereço de rede ipv4 ou ipv6:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">}
</span></code></pre></pre>
<p>Declaramos as variantes do enumerado delimitadas por <code>,</code>.
Acessamos o valor do enumerado pelo delimitador <code>::</code> logo após o nome do <em>enum</em>.
Podemos declarar uma variável tal como <code>ip_kind: IpAddrKind</code> e esta variável pode conter as valores <code>IpAddrKind::V4</code> ou <code>IpAddrKind::V6</code>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">   V4,
</span><span class="boring">   V6,
</span><span class="boring">}
</span>fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {
}
</code></pre></pre>
<p>Observe como foram feitas as declarações, atribuições e o teste com <em>if</em>.</p>
<h3 id="enumerados-algébricos"><a class="header" href="#enumerados-algébricos">Enumerados algébricos</a></h3>
<p>Um grande diferencial do Rust é que os enumerados podem associar valores. E cada variante do <em>enum</em> pode ter diferentes tipos:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4(u8, u8, u8, u8),
    V6(u16, u16, u16, u16, u16, u16, u16, u16),
}

fn main() {
    let four = IpAddrKind::V4(192, 168, 0, 1);
    let six = IpAddrKind::V6(0, 0, 0, 128, 0, 0, 255, 255);

    route(four);
    route(six);
}

fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Mesmo parecendo serem de tipos de dados totalmente diferente podemos passar como parâmetro na função <code>route</code>.
No exemplo acima <code>V4</code> e <code>V6</code> funcionam como tuplas.</p>
<h3 id="recuperando-valores-associados-de-enums-com-if-let"><a class="header" href="#recuperando-valores-associados-de-enums-com-if-let">Recuperando valores associados de enums com <code>if let</code></a></h3>
<p>Para obtermos os valores dos enums podemos usar o comando <code>if let</code>.
Seria como dizer algo como &quot;caso variável for tipo <em>enum</em> então capture o valor associado e faça...&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4(u8, u8, u8, u8),
</span><span class="boring">    V6(u16, u16, u16, u16, u16, u16, u16, u16),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4(192, 168, 0, 1);
</span><span class="boring">    let six = IpAddrKind::V6(0, 0, 0, 128, 0, 0, 255, 255);
</span><span class="boring">
</span><span class="boring">    route(four);
</span><span class="boring">    route(six);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {
    if let IpAddrKind::V4(a1, a2, a3, a4) = ip_kind {
        println!(&quot;ipv4: {}.{}.{}.{}&quot;, a1, a2, a3, a4);
    }
    if let IpAddrKind::V6(a1, a2, a3, a4, a5, a6, a7, a8) = ip_kind {
        println!(&quot;ipv6: {}:{}:{}:{}:{}:{}:{}:{}&quot;, a1, a2, a3, a4, a5, a6, a7, a8);
    }
}
</code></pre></pre>
<p>No <code>if let</code> os valores associados ao <em>enum</em> são acessados através de variáveis que valem somente para o escopo do <code>if</code>.</p>
<h3 id="recuperando-valores-associados-com-match"><a class="header" href="#recuperando-valores-associados-com-match">Recuperando valores associados com <code>match</code></a></h3>
<p>Semelhante como foi feito com <code>if let</code>, podemos utilizar o <code>match</code>, com a vantagem que podemos testar todas as possibilidades dentro do mesmo bloco:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4(u8, u8, u8, u8),
</span><span class="boring">    V6(u16, u16, u16, u16, u16, u16, u16, u16),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4(192, 168, 0, 1);
</span><span class="boring">    let six = IpAddrKind::V6(0, 0, 0, 128, 0, 0, 255, 255);
</span><span class="boring">
</span><span class="boring">    route(four);
</span><span class="boring">    route(six);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {
    match ip_kind {
        IpAddrKind::V4(a1, a2, a3, a4) =&gt; {
            println!(&quot;ipv4: {}.{}.{}.{}&quot;, a1, a2, a3, a4);
        },
        IpAddrKind::V6(a1, a2, a3, a4, a5, a6, a7, a8) =&gt; {
            println!(&quot;ipv6: {}:{}:{}:{}:{}:{}:{}:{}&quot;, a1, a2, a3, a4, a5, a6, a7, a8);
        }
    }
}
</code></pre></pre>
<p>Uma das formas mais comuns de se transformar um <code>enum</code> é utilizar o comportamento de expressão do <em>pattern match</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4(u8, u8, u8, u8),
</span><span class="boring">    V6(u16, u16, u16, u16, u16, u16, u16, u16),
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let four = IpAddrKind::V4(192, 168, 0, 1);
    let six = IpAddrKind::V6(0, 0, 0, 128, 0, 0, 255, 255);

    let formatted = fmt_addr(&amp;four);
    println!(&quot;Formatted: {}&quot;, formatted);
}

fn fmt_addr(ip_kind: &amp;IpAddrKind) -&gt; String {
    match ip_kind {
        IpAddrKind::V4(a1, a2, a3, a4) =&gt; {
            format!(&quot;ipv4: {}.{}.{}.{}&quot;, a1, a2, a3, a4)
        },
        IpAddrKind::V6(a1, a2, a3, a4, a5, a6, a7, a8) =&gt; {
            format!(&quot;ipv6: {}:{}:{}:{}:{}:{}:{}:{}&quot;, a1, a2, a3, a4, a5, a6, a7, a8)
        }
    }
}
</code></pre></pre>
<h3 id="enumerado-estruturado"><a class="header" href="#enumerado-estruturado">Enumerado estruturado</a></h3>
<p>Além de permitir armazenas valores como tuplas o <em>enum</em> também pode conter dado estruturado, permitindo nomear os campos:</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4 {
        a: u8,
        b: u8,
        c: u8,
        d: u8
    },
}

fn main() {
    let four = IpAddrKind::V4{ a: 192, b: 168, c: 0, d: 1 };

    let formatted = fmt_addr(&amp;four);
    println!(&quot;Formatted: {}&quot;, formatted);
}

fn fmt_addr(ip_kind: &amp;IpAddrKind) -&gt; String {
    match ip_kind {
        IpAddrKind::V4{a: p1, b: p2, c: p3, d: p4 } =&gt; {
            format!(&quot;ipv4: {}.{}.{}.{}&quot;, p1, p2, p3, p4)
        },
    }
}
</code></pre></pre>
<p>Observe que <code>match</code> desconstruiu os campos do enumerado.</p>
<h2 id="introdução-sobre-ownership-e-borrowing"><a class="header" href="#introdução-sobre-ownership-e-borrowing">Introdução sobre <em>Ownership</em> e <em>Borrowing</em></a></h2>
<blockquote>
<p>Rust ser uma linguagem <strong>sem <em>Garbage Collector</em></strong> e <strong>evitar problemas com referências</strong> são incríveis feitos.
Para permitir isso foi necessário incluir na linguagem alguns conceitos que não existem em outras.
Então é comum termos alguma dificuldade, mas depois que entendemos passamos a ficar mais fluente e mais produtivo na linguagem.</p>
</blockquote>
<p>Primeiramente iremos falar sobre conceitos.</p>
<h3 id="tempo-de-validade-das-variáveis"><a class="header" href="#tempo-de-validade-das-variáveis">Tempo de validade das variáveis</a></h3>
<p>As variáveis possuem seu tempo de vida válido dentro do escopo onde são definidas.
Geralmente o escopo vale para um bloco delimitado por <code>{}</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {                      // s is not valid here, it’s not yet declared
        let s = &quot;hello&quot;;   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
    println!(&quot;bye&quot;);
}
</code></pre></pre>
<p>Quando termina o escopo onde a variável está declarada ocorre o <code>drop</code>, a variável é desalocada.</p>
<h3 id="diferença-entre-sintaxe-e-semântica"><a class="header" href="#diferença-entre-sintaxe-e-semântica">Diferença entre sintaxe e semântica</a></h3>
<p>Cada linguagens obedece as suas regras de sintaxe e semântica.
O exemplo Java abaixo possui sintaxe correta e semântica também correta:</p>
<pre><code class="language-java">var a = 1;
var b = 2;
var c = a + b;
</code></pre>
<p>Porém o seguinte exemplo possui sintaxe correta mas a semântica está errada:</p>
<pre><code class="language-java">var a = 1;
var b = false;
var c = a + b;
</code></pre>
<p>Este outro exemplo possui a mesma sintaxe do primeiro exemplo,
mas pela semântica faz algo totalmente diferente do primeiro exemplo
(concatena texto, não soma):</p>
<pre><code class="language-java">var a = &quot;Hello &quot;;
var b = &quot;World&quot;;
var c = a + b;
</code></pre>
<p>A sintaxe olha para regra de símbolos e identificadores, a semântica olha para o tipo das variável e resulta num comportamento diferente.
Quando ouvirem falar de &quot;semântica&quot; tentem associar que o comportamento vai depender do tipo da variável ou do contexto.</p>
<h3 id="variáveis-reference-e-variáveis-value"><a class="header" href="#variáveis-reference-e-variáveis-value">Variáveis <code>reference</code> e variáveis <code>value</code></a></h3>
<p>Vamos recapitular um conceito utilizado em muitas linguagens,
que são sobre variáveis <em>reference</em> e variáveis <em>value</em>. Para entendermos ver um exemplo em Java, que estamos mais familiarizados:</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class MyClass {

    public static void main(String args[]) {
        int x = 10;
        int y = x;
        System.out.println(&quot;x = &quot; + x);
        System.out.println(&quot;y = &quot; + y);

        int y = 0;
        System.out.println(&quot;x = &quot; + x);
        System.out.println(&quot;y = &quot; + y);
    }
}
</code></pre>
<p>Na linha <code>int y = x</code> ocorre a semântica <code>copy</code>, onde valor da variável é copiado para outra variável.
Em Java variáveis primitivas não possuem referência,
o sinal de atribuição sempre faz a copia o valor - cada variável aponta para um valor de área de memória diferente.</p>
<p>Porém o exemplo abaixo ocorre algo diferente:</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.List;

public class MyClass {
    public static void main(String args[]) {
        var l1 = new ArrayList&lt;Integer&gt;(List.of(0, 1, 2, 3));
        var l2 = l1;
        System.out.println(&quot;l1 = &quot; + l1.toString());
        System.out.println(&quot;l2 = &quot; + l2.toString());

        l2.clear();
        System.out.println(&quot;l1 = &quot; + l1.toString());
        System.out.println(&quot;l2 = &quot; + l2.toString());
    }
}
</code></pre>
<p>Na linha <code>var l2 = l1</code> faz que as duas varáveis referenciem o mesmo valor sem ocorrer o <code>copy</code>.
Java permite que duas variáveis sejam donas do mesmo valor,
é papel do <em>GC</em> ficar controlando que as duas variáveis sairão de contexto para poder dropar o valor.</p>
<blockquote>
<p>Observe que é comum de iniciantes da programação terem dificuldade para entender
o conceito de referência, por exemplo, acharem que podemos copiar uma nova lista fazendo <code>ArrayList l2 = l1</code>.</p>
</blockquote>
<p>No Java não há nenhum alerta, mas a linha <code>l2.clear()</code> faz algo muito perigoso,
pois a lista é inicializada enquanto existe outra variável l1 referenciando o mesmo objeto.</p>
<h3 id="ownership-e-a-semântica-move"><a class="header" href="#ownership-e-a-semântica-move"><em>Ownership</em> e a semântica <em>move</em></a></h3>
<p>Para evitar o tipo de problema acima, Rust introduz o conceito e <em>Ownership</em>.</p>
<p>Podemos ter mais de uma variável apontando para um valor,
mas somente uma dessas variáveis deve ser a dona (<em>owner</em>).</p>
<blockquote>
<p>Quando um valor troca de dono dizemos que ocorreu um <em>move</em>.</p>
</blockquote>
<p>Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello&quot;);
let s2 = s1;
println!(&quot;{}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Quando fizemos a atribuição <code>let s2 = s1</code> ocorreu o <em>move</em> do valor de <code>s1</code> para <code>s2</code>,
ou seja, <code>s2</code> passou a ser <em>owner</em>.
A partir desse momento não podemos mais acessar a variável <code>s1</code>.</p>
<p>Então exemplo abaixo ocorre erro de compilação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello&quot;);
let s2 = s1;
println!(&quot;{}&quot;, s1); // &lt;== Ocorre erro aqui!
println!(&quot;{}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<h2 id="borrowing-referência"><a class="header" href="#borrowing-referência"><em>Borrowing</em> (referência)</a></h2>
<p>No exemplo acima podemos resolver o problema de compilação fazendo <code>s2</code>
pegar &quot;emprestado&quot; (<em>borrowing</em>) a referência ao <code>s1</code>, através do caracteres <code>&amp;</code>. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello&quot;);
let s2 = &amp;s1;
println!(&quot;{}&quot;, s1);
println!(&quot;{}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Nesse caso tanto <code>s1</code> quanto <code>s2</code> apontam para o mesmo valor <code>Hello</code>, porém s1 que é o <em>owner</em>.</p>
<blockquote>
<p>O tempo de vida do valor é determinado pelo escopo da variável <em>owner</em>, não das referências.</p>
</blockquote>
<h2 id="semântica-copy"><a class="header" href="#semântica-copy">Semântica <em>copy</em></a></h2>
<p>Vamos ver outro exemplo em Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 10;
    let y = x;
    println!(&quot;x = {}&quot;, x);
    println!(&quot;y = {}&quot;, y);
}
</code></pre></pre>
<p>Na linha <code>let y = x</code> na verdade y está dizendo &quot;quero ser dono do valor 10&quot;, que já tem x como dono.
Mas isso violaria a regra &quot;somente pode haver um <em>owner</em> por vez&quot;. Para tentar resolver a situação
o compilador verifica se a variável implementa a <em>trait</em> (interface) <code>Copy</code>.
Se sim, então ocorre uma clonagem implícita do valor para a outra variável,
então agora cada variável referencia um valor diferente.
No Rust tipos &quot;primitivos&quot; implementam o <code>Copy</code>, diferente de quanto usamos <em>String</em>, o caso acima compila.</p>
<blockquote>
<p>Para facilitar o entendimento vamos fazer uma analogia o Java, onde valores primitivos não possuem referência, sempre são <em>by value</em>.</p>
</blockquote>
<p>Mas diferente do Java onde somente tipos primitivos usam a semântica copy, em Rust nós podemos implementar a interface <code>Copy</code> para tipos nossos.</p>
<blockquote>
<p>Em resumo, em Rust para alguns tipos não ocorrerá erros de compilação se não usar o &amp;, mas implicitamente estará fazendo <em>copy</em> do valor.</p>
</blockquote>
<h2 id="borrow-checker"><a class="header" href="#borrow-checker"><em>Borrow checker</em></a></h2>
<blockquote>
<p>Esta são as regras do <em>borrow checker</em>:</p>
<ul>
<li>Somente pode haver um <em>owner</em> por vez</li>
<li>Quando o <em>owner</em> sai de escopo, seu valor é <em>dropped</em> (dropado)</li>
<li>Para um valor ser dropado não pode existir nenhum <em>borrowing</em> vivo no escopo</li>
</ul>
</blockquote>
<p>Devemos ter em mente que quando declaramos variável ou parâmetro <em>Owned</em> é como se estivéssemos no apropriando do valor, ou seja,
talvez até consumindo o valor de outra variável.</p>
<p>Um exemplo que provoca o valor ser movido e causa erro de compilação:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    say_word(s1);
    println!(&quot;s1 = {}&quot;, s1);
}

fn say_word(word: String) {
    println!(&quot;{}&quot;, word);
}
</code></pre></pre>
<p>Da forma que o parâmetro da função foi declarado, a variável acaba sendo movida e
não pode ser acessada depois de chamar a função. Para resolvermos isso podemos fazer <em>borrowing</em>,
declarar a função com parâmetro <code>s: &amp;String</code> e passar a variável com <code>&amp;s1</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    say_word(&amp;s1);
    println!(&quot;s1 = {}&quot;, s1);
}

fn say_word(word: &amp;String) {
    println!(&quot;{}&quot;, word);
}
</code></pre></pre>
<p>Não há necessidade da função <code>say_word</code> &quot;consumir&quot; o parâmetro, ele pode receber uma referência.</p>
<p>Quando fazemos um <code>for i in lista</code> por baixo dos panos é criado um <em>iterator</em> que acaba consumindo os elementos.
Então se fizermos o laço duas vezes ocorre erro de compilação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut lista = Vec::new();
lista.push(1);
lista.push(2);
lista.push(3);

println!(&quot;Lista 1&quot;);
for i in lista {
    println!(&quot;{:?}&quot;, i);
}
println!(&quot;Lista 2&quot;);
for i in lista {  // &lt;=== erro aqui! o valor foi movido no primeiro laço
    println!(&quot;{:?}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>Para resolver basta fazermos o laço com <code>&amp;lista</code> ou chamar <code>lista.iter()</code> (que já acessa retorna os elementos por referência)</p>
<p>===&gt; Criar exemplo que insere entre duas listas</p>
<p>Muitas vezes acessaremos variáveis por referência, que como sabemos deve existir</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let texto_out = String::from(&quot;hello&quot;);
    let mut textos = Vec::with_capacity(2);
    textos.push(&amp;texto_out);
    {
        let texto_in = String::from(&quot;hello&quot;);
        textos.push(&amp;texto_in);
    }
    println!(&quot;{:?}&quot;, textos);
}
</code></pre></pre>
<h2 id="clonagem-copy-explícito"><a class="header" href="#clonagem-copy-explícito">Clonagem (<em>copy</em> explícito)</a></h2>
<p>A operação de <code>clone</code> é semelhante o <code>copy</code>, que cria uma nova variável, duplicando seu valor.
Porém o <code>copy</code> é chamado implicitamente pelo compilador para variáveis que implementam a interface <code>Copy</code>,
no caso <code>clone</code> deve chamado pelo programador.
Para tipos de tamanho variável podemos usar o <code>clone</code>.</p>
<p>Clonagem é um artíficio que podemos usar para satisfazer a regra de referências.</p>
<p>Vamos voltar a um dos exemplos que não compila.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
println!(&quot;s1 = {}&quot;, s1);
println!(&quot;s2 = {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Podemos fazer compilar com <code>s1.clone()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
println!(&quot;s1 = {}&quot;, s1);
println!(&quot;s2 = {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Outro exemplo que não compila:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
    say_word(s1); // &lt;- ocorre o move aqui
    // não posso acessar s1
}

fn say_word(word: String) {
    println!(&quot;{}&quot;, word);
    // word sofre drop
}
</code></pre></pre>
<p>Para ajustarmos:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hello&quot;);
    say_word(s1.clone()); // &lt;- ocorre o move aqui
    // posso acessar s1
}

fn say_word(word: String) {
    println!(&quot;{}&quot;, word);
    // word sofre drop
}
</code></pre></pre>
<p>Nos dois exemplos, mesmo passando parâmetros <em>owned</em>, a variável continua válida no contexto pois acabamos movendo um valor clonado.</p>
<h3 id="observações-sobre-ownership-e-borrowing"><a class="header" href="#observações-sobre-ownership-e-borrowing">Observações sobre <em>Ownership</em> e <em>Borrowing</em></a></h3>
<p>Estes são conceitos novos que não existem em outras linguagens, então é normal demorarmos
para assimilar. Porém é graças a este conceito que Rust proporciona uma grande robustez e
performance.</p>
<p>É comum termos que decidir se nossas funções terão parâmetros <em>Owned</em> ou <em>Borrowed</em>.
Para tomarmos esse tipo de decisão podemos pensar no conceito de <em>Ownership</em> como ser fosse um conceito de <strong>fluxo de dados</strong>,
por exemplo: a variável que estamos declarando desejamos passar a diante
para a outra rotina (passar <em>Owned</em>) para ser &quot;consumida&quot; ou deve &quot;ir e voltar&quot; (passar <em>Borrowed</em>).</p>
<p>Este é um <em>mindset</em> que com o tempo iremos adquirir de forma natural.</p>
<p>Vamos ver o exemplo abaixo:</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    id: u32,
    name: String,
}

fn current_name() -&gt; String {
    String::from(&quot;USERNAME&quot;)
}

fn create_user(user_name: String) -&gt; User {
    User {
        id: 1,
        name: user_name,
    }
}

fn main() {
    let current_user = current_name();
    let user = create_user(current_user);
    println!(&quot;Hello, {}-{}!&quot;, user.id, user.name);
}
</code></pre></pre>
<p>A <em>string</em> <code>USERNAME</code> foi trocando de escopo sem ocorrer nenhuma cópia do valor.
Como a função <code>create_user</code> precisa &quot;consumir&quot; o nome para devolver como campo do objeto <code>User</code>
então faz sentido o parâmetro ser <em>owned</em>.</p>
<blockquote>
<p>A grande vantagem do Rust é que compilador dá dicas de quando estamos confundindo entre <em>Owned</em> ou <em>Borrowed</em>,
<strong>podemos ir arriscando que o compilador vai nos guiando</strong>, não teremos nenhum <em>NullPointerException</em> ou <em>AccessViolation</em>.</p>
</blockquote>
<h3 id="referências-mutáveis"><a class="header" href="#referências-mutáveis">Referências mutáveis</a></h3>
<p>Se queremos ter uma função que altera o conteúdo da variável por referência
devemos utilizar o modificador <code>&amp;mut T</code> tanto na passagem de parâmetro quanto na declaração da função:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<h3 id="regras-de-ownership-e-borrow-checker"><a class="header" href="#regras-de-ownership-e-borrow-checker">Regras de ownership e borrow checker</a></h3>
<ul>
<li>Para uma variável ser movida (trocar <em>owned</em>) não pode existir nenhuma outra referência</li>
<li>A referência não pode viver mais do que a variável <em>owned</em></li>
<li>Só é possível ter uma referência mutável de cada vez</li>
<li>Para haver uma referência mutável não pode existir nenhuma outra referência</li>
</ul>
<p>Vamos ver o exemplo que viola a regra &quot;só é possível ter uma referência mutável de cada vez&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre></pre>
<p>A vantagem de ter essa restrição é que o Rust pode evitar disputas de dados em tempo de compilação.
Uma corrida de dados é semelhante a uma condição de corrida e acontece quando esses três comportamentos ocorrem:</p>
<ul>
<li>Dois ou mais ponteiros acessam os mesmos dados ao mesmo tempo.</li>
<li>Pelo menos um dos ponteiros está sendo usado para gravar os dados.</li>
<li>Nenhum mecanismo está sendo usado para sincronizar o acesso aos dados.</li>
</ul>
<p>Ajustando o código abaixo ele compila:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;

    println!(&quot;{}&quot;, r2);
<span class="boring">}
</span></code></pre></pre>
<p>O exemplo acima foi resolvido pois agora possuem tempo de vida e escopo diferentes.</p>
<p>Vamos ver um exemplo que viola a regra &quot;não podemos ter uma referência mutável se já existem alguma outra não mutável&quot;:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Porém podemos resolver esse problema apenas alterando a ordem de declaração e uso:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // r1 and r2 are no longer used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Então o escopo da variável na verdade vale até o seu uso.</p>
<h2 id="compatibilidade-de-tipos-e-de-referência"><a class="header" href="#compatibilidade-de-tipos-e-de-referência">Compatibilidade de tipos e de-referência</a></h2>
<p>Como podemos deduzir os tipos <code>T</code> e <code>&amp;T</code> não são compatíveis, ou seja,
não é possível atribuir ou comparar entre esses dois tipos.
Se tenho uma parâmetro <code>&amp;T</code> mas tenho uma variável <code>T</code> então basta informar o caractere <code>&amp;</code> antes da variável.</p>
<p>Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = &amp;s1;
    if s1 == s2 {
        println!(&quot;Equal&quot;);
    } else {
        println!(&quot;Not equal&quot;);
    }
}
</code></pre></pre>
<p>Ocorre um erro de compilação em <code>s1 == s2</code>. Para resolver devemos fazer:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">   let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">   let s2 = &amp;s1;
</span>    if &amp;s1 == s2 {
<span class="boring">       println!(&quot;Equal&quot;);
</span><span class="boring">   } else {
</span><span class="boring">       println!(&quot;Not equal&quot;);
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre></pre>
<p>Para o fazer o contrário, a partir de uma variável <code>&amp;T</code> obter o valor <code>T</code>, então posso usar o caractere <code>*</code> para fazer a de-referência.
Em geral Rust faz de-referência automaticamente, entretanto principalmente para comparações devemos utilizar:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">   let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">   let s2 = &amp;s1;
</span>    if s1 == *s2 {
<span class="boring">       println!(&quot;Equal&quot;);
</span><span class="boring">   } else {
</span><span class="boring">       println!(&quot;Not equal&quot;);
</span><span class="boring">   }
</span><span class="boring">}
</span></code></pre></pre>
<h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>Em Rust as principais <em>collections</em> são <code>Vec</code> (equivalente ao <code>ArrayList</code> em Java), <code>HashMap</code> e <code>HashSet</code>. Em geral esses tipos de estrutura de dados se assemelham a outras linguagens.</p>
<h2 id="vec"><a class="header" href="#vec">Vec</a></h2>
<p>Para criarmos um <code>Vec</code> podemos usar a notação <em>generic</em> semelhante ao Java. Para inserir itens
usamos o método <code>push</code>. Para iterar os itens podemos usar <code>for in</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v1: Vec&lt;i32&gt; = Vec::new();
v1.push(0);
v1.push(1);
v1.push(2);
for i in v1 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>Uma característica muito interessante de Rust é que ele pode inferir o tipo dos elementos através do primeiro uso, sem necessidade da notação de <em>generic</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v1 = Vec::new();
v1.push(0);
<span class="boring">}
</span></code></pre></pre>
<p>Para inserir inicializar um <code>Vec</code> com elementos podemos usar a macro <code>vec!</code>, ocupando menos linhas de código:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v1 = vec![0, 1, 2];
for i in v1 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>O tamanho do <code>Vec</code> é retornado pelo método <code>len</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v1 = vec![0, 1, 2];
println!(&quot;{}&quot;, v1.len());
<span class="boring">}
</span></code></pre></pre>
<h2 id="compatibilidade-entre-vec-e-array"><a class="header" href="#compatibilidade-entre-vec-e-array">Compatibilidade entre <code>Vec</code> e <em>array</em></a></h2>
<p>Um <code>&amp;Vec&lt;T&gt;</code> pode ser convertido <code>&amp;[T]</code>, ou seja, podemos converter um <code>Vec</code> (dinâmico) para <em>array</em> (estático). Isso é interessante pois podemos criar funções genéricas que aceitam
os dois tipos. Em Java por exemplo, <em>array</em> e <code>ArrayList</code> não são compatíveis.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut v = vec![0, 1, 2]; // Vec
    list(&amp;v);
    let a = [0, 1, 2]; // array
    list(&amp;a);
}

fn list(l: &amp;[i32]) {
    for i in l {
        println!(&quot;{:?}&quot;, i);
    }
}
</code></pre></pre>
<p>O <em>Array</em> possui o método <code>to_vec</code> para converter para <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring"> fn main() {
</span>let a = [0, 1, 2]; // array
let v = a.to_vec(); // vec
list(&amp;v);
<span class="boring">}
</span><span class="boring">fn list(l: &amp;[i32]) {
</span><span class="boring">    for i in l {
</span><span class="boring">        println!(&quot;{:?}&quot;, i);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>O <code>Vec</code> possui o método <code>as_slice</code> para converter para <em>array</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring"> fn main() {
</span>let mut v = vec![0, 1, 2]; // Vec
let a = v.as_slice(); // array
list(&amp;a);
<span class="boring">}
</span><span class="boring">fn list(l: &amp;[i32]) {
</span><span class="boring">    for i in l {
</span><span class="boring">        println!(&quot;{:?}&quot;, i);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>Rust se assemelha um pouco a Java no sentido que existe uma distinção entre <em>collection</em> e <em>stream</em>.
As principais <em>collections</em> são <em>Vec</em>, <em>HashSet</em> e <em>HashMap</em>.
Para cada collection podemos gerar um <em>stream</em>, que em Rust o <em>stream</em> chamamos de <em>Iterator</em>.
Ele permite fazer operações encadeadas tal como <em>filter</em>, <em>map</em>, <em>reduce</em>, <em>any</em>, <em>find</em>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![0, 1, 2, 3, 4, 5];
    let odds = v.into_iter().filter(|n| n % 2 == 1).collect::&lt;Vec&lt;_&gt;&gt;();

    for i in odds {
        println!(&quot;{:?}&quot;, i);
    }
}
</code></pre></pre>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<p>O tipo <code>Option</code> é de extrema importância para o Rust garantir o comportamento de <em>null safe</em>.</p>
<p>Alguns casos de uso:</p>
<ul>
<li>Valores iniciais</li>
<li>Argumentos de funções opcionais</li>
<li>Retorno de funções parciais (que podem não retornar nada)</li>
<li>Campos que podem ser retirados/movidos</li>
</ul>
<p>Funciona de forma muito semelhante ao <code>Optional</code> do Java.</p>
<p>Na verdade <code>Option</code> é um <code>enum</code> de variantes <code>None</code> e <code>Some(T)</code>. <code>None</code> indica nenhum conteúdo e <code>Some</code> é uma variante algébrica.</p>
<p>Para declarar usamos a sintaxe semelhante ao Java:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a: Option&lt;u32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>No exemplo acima vemos o uso da notação de <code>generic</code>, também muito semelhante ao Java.</p>
<p>Ao declarar um <code>Option</code> com valor válido podemos declarar das seguintes formas, com tipo explícito e inferido:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a: Option&lt;u32&gt; = Some(1);
let b = Some(1);
<span class="boring">}
</span></code></pre></pre>
<p>Comumente <code>Option</code> é utilizado com <em>pattern match</em>, por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn divide(numerator: f64, denominator: f64) -&gt; Option&lt;f64&gt; {
    if denominator == 0.0 {
        None
    } else {
        Some(numerator / denominator)
    }
}

fn main() {
    // The return value of the function is an option
    let result = divide(2.0, 3.0);

    // Pattern match to retrieve the value
    match result {
        // The division was valid
        Some(x) =&gt; println!(&quot;Result: {}&quot;, x),
        // The division was invalid
        None    =&gt; println!(&quot;Cannot divide by 0&quot;),
    }
}
</code></pre></pre>
<p>A forma mais segura de obter um valor de um <code>Option</code> é através de <code>match</code> e <code>if let</code>.
A forma menos segura, equivalente ao <code>get</code> do Java , é através do <code>unwrap</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a: Option&lt;u32&gt; = Some(1);
let n = a.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Esse método é perigoso, devemos usar somente quando termos certeza do que estamos fazendo.
Se o <code>Option</code> possuir <code>None</code> irá levantar uma erro <code>panic</code> e interromper a execução do programa.</p>
<p>Para retornar um <code>default</code> quando o valor não existe podemos usar o <code>unwrap_or</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let opt_none: Option&lt;i32&gt; = None;
let result = opt_none.unwrap_or(1);
<span class="boring">}
</span></code></pre></pre>
<p>Porém observe que nesse caso o valor 1 é sempre passado como parâmetro, mesmo se não for usado.
Eventualmente é interessante o valor ser obtido por callback( <code>closure</code> ou lambda), principalmente
quando queremos passar uma função. Nesse caso usamos <code>unwrap_or_else</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let opt_none: Option&lt;i32&gt; = None;
let result = opt_none.unwrap_or_else(|| 1);
<span class="boring">}
</span></code></pre></pre>
<p>Os caracteres indicam <code>||</code> passagem de parâmetro de lambda, semelhante como no Ruby.</p>
<p>Observe que <code>unwrap_or</code> e <code>unwrap_or_else</code> não modificam o conteúdo do <code>Option</code>,
apenas retorna o valor <code>default</code>.</p>
<p>Caso o nosso desejo for de realmente alterar o conteúdo do <code>Option</code>, como um <em>lazyload</em>,
então podemos usar <code>get_or_insert_with</code>. Nesse caso devemos declarar o <code>Option</code> com <code>mut</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut opt_none: Option&lt;i32&gt; = None;
let result = opt_none.get_or_insert_with(|| 1);
<span class="boring">}
</span>
Também podemos encadear vários `Option`, com `or`, `and` e `and_then`:

```rust
fn double_opt(i: i32) -&gt; Option&lt;i32&gt; {
    Some(i * 2)
}

<span class="boring">fn main() {
</span>    let opt_some_1 = Some::&lt;i32&gt;(1);
    let opt_some_2 = Some::&lt;i32&gt;(2);
    let opt_some_3 = Some::&lt;i32&gt;(3);

    let result_or = opt_some_1.or(opt_some_2).or(opt_some_3);
    assert_eq!(result_or, Some(1));

    let result_and = opt_some_1.and(opt_some_2).and(opt_some_3);
    assert_eq!(result_and, Some(3));

    let result_or = opt_some_1.and_then(double_opt).and_then(double_opt);
    assert_eq!(result_or, Some(1));
}
</code></pre></pre>
<h3 id="obtendo-a-referência-do-valor-com-referência"><a class="header" href="#obtendo-a-referência-do-valor-com-referência">Obtendo a referência do valor com referência</a></h3>
<p>Quando o valor do <code>Option</code> contém um tipo que não faz <em>copy</em> implícito, tal como tipo <code>String</code>,
o código abaixo causa um erro de compilação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let opt = Some(String::from(&quot;Rech&quot;));
match opt {
    Some(n) =&gt; {
        println!(&quot;{}&quot;, n)
    }
    None =&gt; {
        println!(&quot;none&quot;)
    }
}
println!(&quot;{:?}&quot;, opt);
<span class="boring">}
</span></code></pre></pre>
<p>É retornada a mensagem:</p>
<pre><code>borrow of partially moved value: `opt`
partial move occurs because value has type `std::string::String`, which does not implement the `Copy` trait
</code></pre>
<p>Na linha <code>Some(n)</code> ocorre o <em>move</em> para a variável <code>n</code>, é como se ela fosse &quot;consumida&quot;.
Para evitar isso temos que fazer o match na referência da variável. Temos que fazer <code>match &amp;opt</code> ou <code>match opt.as_ref()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">let opt = Some(String::from(&quot;Rech&quot;));
</span>match &amp;opt {
    Some(n) =&gt; {
        println!(&quot;{}&quot;, n)
    }
    None =&gt; {
        println!(&quot;none&quot;)
    }
}
<span class="boring">println!(&quot;{:?}&quot;, opt);
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="tratamento-de-erros"><a class="header" href="#tratamento-de-erros">Tratamento de erros</a></h2>
<p>Primeiramente vamos recapitular conceitos de erros (ou exceções):</p>
<ul>
<li>
<p><strong>Checado / não checado</strong>. Um erro checado é aquele que obriga a tratarmos na função chamadora e
geralmente deve ser declarado na assinatura da função. Um erro não checado pode ocorrer e não temos
obrigação de tratá-lo, sendo propagado para a função anterior da pilha. Podemos comparar com
Java, onde <code>IOException</code> é checado e <code>NullPointerException</code> não é checado.</p>
</li>
<li>
<p><strong>Recuperável / não recuperável</strong>. Um erro recuperável é aquele que podemos interceptar e tratar.
Um erro não recuperável não podemos tratar e geralmente resulta na finalização de execução do programa. No Java, exemplo de erros não recuperáveis seriam <code>StackOverflowError</code> e <code>OutOfMemoryError</code>.</p>
</li>
</ul>
<p>Em Rust temos dois tipos de erros:</p>
<ul>
<li><code>Result</code>. É checado e é recuperável.</li>
<li><code>Panic</code>. Não é checado e não é recuperável.</li>
</ul>
<h2 id="trabalhando-com-result"><a class="header" href="#trabalhando-com-result">Trabalhando com <code>Result</code></a></h2>
<p>Utilizamos <code>Result</code> no retorno de uma função que pode falhar, ou seja, quando é falível.</p>
<blockquote>
<p>Rust possui um dos modelos de tratamento de erro mais elogiados da atualidade.
O resultado de Ok ou Erro é um único retorno de uma função - é possível armazenar, mover, verificar, transformar, etc.</p>
</blockquote>
<p>É interessante tentarmos imaginar uma exceção como um <code>Option</code>. Num <code>Option</code> se o valor existe (se está ok) então ele representa um <code>Some(T)</code>.</p>
<p>As exceções funcionam parecido. Ao invés do <code>Option&lt;T&gt;</code> usamos outro <em>enum</em>, o <code>Result&lt;T, E&gt;</code>, onde ele pode ser <code>Ok(T)</code> e <code>Err(E)</code>.</p>
<p>Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

fn cria_arquivo(nome_arquivo: &amp;str) -&gt; Result&lt;PathBuf, String&gt; {
    let path = PathBuf::from(nome_arquivo);
    if path.exists() {
        Ok(path)
    } else {
        Err(format!(&quot;Arquivo {} não existe!&quot;, nome_arquivo))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe na função o retorno <code>Result&lt;PathBuf, String&gt;</code>, isso significa que: </p>
<ul>
<li>Retorna <code>Ok(PathBuf)</code> se tudo dá certo </li>
<li>Retorna <code>Error(String)</code> caso falhar</li>
</ul>
<p>O tratamento podemos fazer semelhante como num um <code>Option</code>, usar os comandos <code>if let</code> e <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">fn cria_arquivo(nome_arquivo: &amp;str) -&gt; Result&lt;PathBuf, String&gt; {
</span><span class="boring">   let path = PathBuf::from(nome_arquivo);
</span><span class="boring">   if path.exists() {
</span><span class="boring">       Ok(path)
</span><span class="boring">   } else {
</span><span class="boring">       Err(format!(&quot;Arquivo {} não existe!&quot;, nome_arquivo))
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let retorno =
        if let Ok(path) = cria_arquivo(&quot;c:/temp/arquivo.txt&quot;) {
            format!(&quot;Criou arquivo {:?} corretamente.&quot;, path)
        } else {
            format!(&quot;Erro ao carregar arquivo&quot;)
        };
    println!(&quot;{}&quot;, retorno);
}
</code></pre></pre>
<p>O exemplo acima demonstra a obtenção do retorno com <code>if let</code>.
Observe que o objeto <code>path</code> é válido somente dentro do bloco.</p>
<h2 id="trabalhando-com-panic"><a class="header" href="#trabalhando-com-panic">Trabalhando com <code>panic</code></a></h2>
<p>O erro <code>panic</code> não é checado e geralmente causa a interrupção do programa.
Pode ser chamado pela macro <code>panic!</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // Division by zero triggers a panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>O uso de <code>panic</code> deve ser evitado o máximo possível, principalmente no desenvolvimento de APIs,
pois pode comprometer a execução de toda da aplicação. Nesse caso o ideal é usar erros <code>Result</code>
justamente para ficar claro sobre o seu comportamento (contrato) das funções.</p>
<p>Uma utilização aceitável do <code>panic</code> seria utilizar na inicialização de uma aplicação,
quando falta algum requisito básico do funcionamento.</p>
<h3 id="métodos-unwrap-e-expect"><a class="header" href="#métodos-unwrap-e-expect">Métodos <code>unwrap</code> e <code>expect</code></a></h3>
<p>Como falamos no capítulo sobre <code>Option</code>, o método <code>unwrap</code> tenta obter o seu valor,
caso não possuir causa uma <code>panic</code>. <code>Result</code> também possui o método <code>unwrap</code>, que funciona de maneira semelhante: se for <code>Ok</code> retorna o valor caso contrário causará um <code>panic</code>.
Vamos ver o exemplo:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">fn cria_arquivo(nome_arquivo: &amp;str) -&gt; Result&lt;PathBuf, String&gt; {
</span><span class="boring">   let path = PathBuf::from(nome_arquivo);
</span><span class="boring">   if path.exists() {
</span><span class="boring">       Ok(path)
</span><span class="boring">   } else {
</span><span class="boring">       Err(format!(&quot;Arquivo {} não existe!&quot;, nome_arquivo))
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let path = cria_arquivo(&quot;c:/temp/arquivo.txt&quot;).unwrap();
    println!(&quot;Arquivo criado&quot;);
}
</code></pre></pre>
<p>Se falhar <code>unwrap</code> causa uma <code>panic</code> com uma mensagem genérica,
sem nenhuma informação de contexto. Por exemplo no programa:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = None::&lt;String&gt;;
    assert_eq!(x.unwrap(), &quot;value&quot;);
}
</code></pre></pre>
<p>Ao executar o seguinte texto é exibido na tela:</p>
<pre><code class="language-terminal">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:8:18
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>Esta mensagem pode ser considerada muito genérica. <code>Option</code> e <code>Result</code> possuem o método <code>expect</code>, que funciona como o <code>unwrap</code>, mas permite adicionar uma mensagem de contexto ao <code>panic</code>. Vamos ver como fica agora no exemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = None::&lt;String&gt;;
    assert_eq!(x.expect(&quot;fruits are healthy&quot;), &quot;value&quot;);
}
</code></pre></pre>
<p>É exibido no <em>output</em> o contexto passado no <code>expect</code>:</p>
<pre><code class="language-terminal">thread 'main' panicked at 'fruits are healthy', src/main.rs:7:18
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<h3 id="backtrace-exibição-da-pilha"><a class="header" href="#backtrace-exibição-da-pilha"><code>Backtrace</code> (exibição da pilha)</a></h3>
<p>Por padrão quando ocorre um <code>panic</code> o programa não exibe no <em>output</em> a <em>stack</em> atual (<em>backtrace</em>).
Rust tem esse comportamento pois monitorar a <em>stack</em> corrente gera um <em>overhead</em> (mesmo que mínimo).
Porém podemos ativar o comportamento para exibir o <em>backtrace</em>. Como podemos ver no exemplo anterior, quando ocorre um <code>panic</code> é exibido uma dica no <em>output</em> para definirmos uma variável de ambiente.</p>
<p>Após definir a seguinte variável de ambiente <code>RUST_BACKTRACE=1</code> vamos ver como fica o <em>output</em> do exemplo anterior:</p>
<pre><code class="language-terminal">thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/main.rs:8:18
stack backtrace:
   0: rust_begin_unwind
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/std/src/panicking.rs:493:5
   1: core::panicking::panic_fmt
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:92:14
   2: core::panicking::panic
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/panicking.rs:50:5
   3: core::option::Option&lt;T&gt;::unwrap
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/option.rs:386:21
   4: playground::main
             at ./src/main.rs:8:16
   5: core::ops::function::FnOnce::call_once
             at /rustc/cb75ad5db02783e8b0222fee363c5f63f7e2cf5b/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>Podemos ativar a exibição do <code>backtrace</code> programaticamente:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env::set_var(&quot;RUST_BACKTRACE&quot;, &quot;1&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="obtendo-um-valor-default-para-result"><a class="header" href="#obtendo-um-valor-default-para-result">Obtendo um valor <code>default</code> para <code>Result</code></a></h2>
<p>Como vimos acima o método <code>unwrap</code> e <code>expect</code> tentam obter o valor do <code>Result</code>, se não houver
causa um <code>panic</code>. Eventualmente podemos querer atribuir um valor default caso o retorno falhar.
Para isso existe <code>unwrap_or</code>, semelhante ao <code>Option</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let foo = env::var(&quot;FOO&quot;).unwrap_or(&quot;none&quot;.to_string());
    println!(&quot;{}&quot;, foo);
}
</code></pre></pre>
<h2 id="aprofundando-o-uso-de-result"><a class="header" href="#aprofundando-o-uso-de-result">Aprofundando o uso de <code>Result</code></a></h2>
<p>Vamos supor que queremos obter o objeto <code>path</code> válido dentro do contexto da função chamadora:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">fn cria_arquivo(nome_arquivo: &amp;str) -&gt; Result&lt;PathBuf, String&gt; {
</span><span class="boring">   let path = PathBuf::from(nome_arquivo);
</span><span class="boring">   if path.exists() {
</span><span class="boring">       Ok(path)
</span><span class="boring">   } else {
</span><span class="boring">       Err(format!(&quot;Arquivo {} não existe!&quot;, nome_arquivo))
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() {
    let path =
        match cria_arquivo(&quot;c:/temp/arquivo.txt&quot;) {
            Ok(path) =&gt; path,
            Err(_) =&gt; return,
        };
    println!(&quot;Criou arquivo {:?} corretamente.&quot;, path);
}
</code></pre></pre>
<p>No exemplo acima se ocorrer um erro a rotina é abortada, devido ao <code>return</code>, então o <code>match</code> consegue retornar o <code>path</code>.</p>
<p>O código ainda está com muitas linhas, podemos refatorá-lo em dois passos:</p>
<h4 id="propagando-o-erro-para-função-chamador"><a class="header" href="#propagando-o-erro-para-função-chamador">Propagando o erro para função chamador</a></h4>
<p>Vamos alterar a função <code>main</code> para permitir retornar o erro capturado no <em>match</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">fn cria_arquivo(nome_arquivo: &amp;str) -&gt; Result&lt;PathBuf, String&gt; {
</span><span class="boring">   let path = PathBuf::from(nome_arquivo);
</span><span class="boring">   if path.exists() {
</span><span class="boring">       Ok(path)
</span><span class="boring">   } else {
</span><span class="boring">       Err(format!(&quot;Arquivo {} não existe!&quot;, nome_arquivo))
</span><span class="boring">   }
</span><span class="boring">}
</span>fn main() -&gt; Result&lt;(), String&gt; {
    let path =
        match cria_arquivo(&quot;c:/temp/arquivo.txt&quot;) {
            Ok(path) =&gt; path,
            Err(e) =&gt; return Err(e),
        };
    println!(&quot;Criou arquivo {:?} corretamente.&quot;, path);
    Ok(())
}
</code></pre></pre>
<p>Aqui temos algumas novidades:</p>
<ul>
<li>Observe que na assinatura da função o retorno <code>Result&lt;(), String&gt;</code>. Os parênteses <code>()</code> é chamado como tipo <em>unit</em>, que seria equivalente ao <code>void</code> do Java.</li>
<li>Na última linha da função <code>main</code> temos o <code>Ok(())</code>, que significa que a função executou com sucesso, entretanto não possui uma valor de retorno.</li>
<li>No <code>math</code> quando ocorre erro agora temos <code>Err(e) =&gt; return Err(e)</code></li>
</ul>
<h4 id="syntax-sugar-para-propagação-do-erro"><a class="header" href="#syntax-sugar-para-propagação-do-erro"><em>Syntax sugar</em> para propagação do erro</a></h4>
<p>Vamos substituir a estrutura de <em>match</em> pelo caractere <code>?</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::path::PathBuf;
</span><span class="boring">fn cria_arquivo(nome_arquivo: &amp;str) -&gt; Result&lt;PathBuf, String&gt; {
</span><span class="boring">   let path = PathBuf::from(nome_arquivo);
</span><span class="boring">   if path.exists() {
</span><span class="boring">       Ok(path)
</span><span class="boring">   } else {
</span><span class="boring">       Err(format!(&quot;Arquivo {} não existe!&quot;, nome_arquivo))
</span><span class="boring">   }
</span><span class="boring">}
</span>
fn main() -&gt; Result&lt;(), String&gt; {
    let path = cria_arquivo(&quot;.&quot;)?;
    println!(&quot;Criou arquivo {:?} corretamente.&quot;, path);
    Ok(())
}
</code></pre></pre>
<p>Quando temos o <code>match</code> retornando a variável de sucesso e o erro sendo retornado na função,
podemos usar o caractere <code>?</code>, que funciona como um <em>syntax sugar</em>.</p>
<p>O exemplo acima agora está bem próximo do que estamos acostumados em outras linguagens,
quando o erro é propagado para função chamadora.</p>
<h2 id="generalizando-o-tratamento-de-erro"><a class="header" href="#generalizando-o-tratamento-de-erro">Generalizando o tratamento de erro</a></h2>
<p>Observe que só podemos usar o <code>?</code> nas funções que retornam <code>Result</code>. E existe o requisito que
o tipo <code>Err(E)</code> da função chamada deve ter o mesmo tipo da função chamadora.</p>
<p>Isso pode ser um pouco inconveniente, pois diferentes APIs normalmente possuem retornar diferentes tipos de erro. Ficaria verboso ter que ficar tratando o retorno com <em>match</em>.</p>
<p>Hoje não é possível generalizar os tipos de erros de forma nativa, apesar que estão trabalhando no compilador para melhorar isso. Para permitir <code>?</code> para qualquer tipo, iremos usar a lib <code>anyhow</code>.
Devemos definir a dependência no <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">anyhow = &quot;1.0&quot;
</code></pre>
<p>E definir o uso no topo do fonte:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result
<span class="boring">}
</span></code></pre></pre>
<p>Iremos utilizar a forma do <code>Result&lt;T&gt;</code> sem <code>&lt;E&gt;</code>, pois como o erro será generalizado então não será necessário informar o tipo do erro:</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;()&gt; {
    let path = cria_arquivo(&quot;.&quot;)?;
    println!(&quot;Criou arquivo {:?} corretamente.&quot;, path);
    Ok(())
}
</code></pre></pre>
<p>Observe que declaramos somente <code>Result&lt;()&gt;</code>.</p>
<p>Para levantar um erro definimos um <code>Err</code> passando a macro <code>anyhow!</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return Err(anyhow!(&quot;Missing attribute: {}&quot;, missing));
<span class="boring">}
</span></code></pre></pre>
<p>Existe a macro <code>bail!</code> que já faz o <code>return Err(anyhow!())</code> internamente:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bail!(&quot;Missing attribute: {}&quot;, missing);
<span class="boring">}
</span></code></pre></pre>
<p>A lib <em>anyhow</em> também permite adicionar uma mensagem de contexto ao novo erro que será propagado,
através da função <code>context</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut reader = File::open(&amp;filename)
    .context(format!(&quot;Unable to open '{}'&quot;, filename))?;
<span class="boring">}
</span></code></pre></pre>
<p>Para fazermos um &quot;<em>throw</em>&quot; de um erro qualquer (que não seja do anyhow) devemos usar retornar <code>Err(e.into())</code>, por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn file_reader(filename: &amp;str) -&gt; anyhow::Result&lt;FileReader&gt; {
    let reader = match File::open(filename) {
        Ok(reader) =&gt; reader,
        Err(e) =&gt; {
            eprintln!(&quot;Erro ao obter FileReader: {}. Nome do arquivo: {}.&quot;, e, filename);
            return Err(e.into());
        }
    };
    Ok(reader)
}

<span class="boring">}
</span></code></pre></pre>
<h3 id="comparação-com-java"><a class="header" href="#comparação-com-java">Comparação com Java</a></h3>
<p>Vamos revisar a sintaxe para tratar erro e comparar com Java:</p>
<h4 id="levantando-erro"><a class="header" href="#levantando-erro">Levantando erro:</a></h4>
<p>Java:</p>
<pre><code class="language-java">void Path cria_arquivo() throws Exception {
    throw new Exception(&quot;Arquivo não existe!&quot;);
}
</code></pre>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cria_arquivo() -&gt; Result&lt;PathBuf&gt; {
    return Err(anyhow!(&quot;Arquivo não existe!&quot;));
}
<span class="boring">}
</span></code></pre></pre>
<p>ou usar a macro <code>bail!</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cria_arquivo() -&gt; Result&lt;PathBuf&gt; {
    bail!(&quot;Arquivo não existe!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="chamando-a-função-sem-tratar-propagando-o-erro-para-a-função-anterior"><a class="header" href="#chamando-a-função-sem-tratar-propagando-o-erro-para-a-função-anterior">Chamando a função sem tratar, propagando o erro para a função anterior:</a></h4>
<p>Java:</p>
<pre><code class="language-java">void inicializa() throws Exception {
    cria_arquivo();
}
</code></pre>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inicializa() -&gt; Result&lt;&gt; {
    cria_arquivo()?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="chamando-a-função-tratando-o-erro"><a class="header" href="#chamando-a-função-tratando-o-erro">Chamando a função tratando o erro:</a></h3>
<p>Java:</p>
<pre><code class="language-java">void inicializa() {
    try {
        var arquivo = cria_arquivo();
        System.output.println(&quot;Criou ok &quot; + arquivo);
    } catch (Exception ex) {
        System.output.println(&quot;Não criou arquivo, erro &quot; + ex);
    }
}
</code></pre>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inicializa() {
    match cria_arquivo() {
        Ok(arquivo) =&gt; println!(&quot;Criou ok {:?}&quot;, arquivo),
        Err(e) =&gt; println!(&quot;Não criou arquivo, erro {:?}&quot;, e),
    };
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tratando-e-levantando-a-exceção"><a class="header" href="#tratando-e-levantando-a-exceção">Tratando e levantando a exceção</a></h3>
<p>Java:</p>
<pre><code class="language-java">void inicializa() throws Exception {
    try {
        var arquivo = cria_arquivo();
        System.output.println(&quot;Criou ok &quot; + arquivo);
    } catch (Exception ex) {
        System.output.println(&quot;Não criou arquivo, erro &quot; + ex);
        throw ex;
    }
}
</code></pre>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inicializa() -&gt; Result&lt;()&gt; {
    match cria_arquivo() {
        Ok(arquivo) =&gt; println!(&quot;Criou ok {:?}&quot;, arquivo),
        Err(e) =&gt; {
            println!(&quot;Não criou arquivo, erro {:?}&quot;, e);
            return Err(e);
        }
    };
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="tratando-e-definindo-um-default"><a class="header" href="#tratando-e-definindo-um-default">Tratando e definindo um default</a></h3>
<p>Java:</p>
<pre><code class="language-java">void inicializa() {
    var arquivo;
    try {
        arquivo = cria_arquivo();
    } catch (Exception ex) {
        arquivo = &quot;default.ini&quot;;
    }
}
</code></pre>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inicializa() {
    let arquivo = cria_arquivo().unwrap_or_else(|e|&quot;default.ini&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="visibilidade-das-funções-falíveis"><a class="header" href="#visibilidade-das-funções-falíveis">Visibilidade das funções falíveis</a></h4>
<p>Uma observação: outra vantagem do caractere <code>?</code> é que ele deixa explícito quais funções podem causar erro. No Java por exemplo:
fica obscuro onde isso ocorre.</p>
<pre><code class="language-java">public void main() throws IOException {
    inicializa();
    cria_arquivo();
    finaliza();
}
</code></pre>
<p>Em Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn void main() -&gt; Result&lt;()&gt; {
    inicializa()?;
    cria_arquivo()?;
    finaliza();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="mapear-erro-para-adicionar-contexto"><a class="header" href="#mapear-erro-para-adicionar-contexto">Mapear erro para adicionar contexto</a></h2>
<p>Um método que pode ser útil é <code>map_err</code> que é um <em>callback</em>
onde podemos trocar para um novo tipo de erro e então
adicionar contexto. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let output = Command::new(program)
    .args(args)
    .current_dir(&amp;directory)
    .output()
    .map_err(|e| {
        anyhow!(
            &quot;{:?}. Erro ao executar comando {} no diretório {}&quot;,
            e,
            program.to_string_lossy(),
            directory.to_string_lossy()
        )
    })?;
<span class="boring">}
</span></code></pre></pre>
<h2 id="convertendo-option-para-result"><a class="header" href="#convertendo-option-para-result">Convertendo <code>Option</code> para <code>Result</code></a></h2>
<p>Eventualmente alguma API pode retornar um <code>Option</code> onde queremos &quot;forçar&quot; a funcionar como um <code>Result</code>.
Podemos imaginar como se fosse levantar um erro a partir de um <code>Option</code>.
Para isso podemos usar o método <code>ok_or</code> passando por parâmetro o erro que será gerado.
Logo em seguida é possível usarmos o caracteres <code>?</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Retorna versão atualizada a partir do base do siger.ini
fn versao_from_siger_ini(siger_ini: &amp;PathLocal) -&gt; anyhow::Result&lt;VersaoSig&gt; {
    let ini = Ini::load_from_file(siger_ini)?;
    let mut versao = ini
        .get_from(Some(&quot;SIGER&quot;), &quot;VS-FUNATU&quot;)
        .ok_or(anyhow!(&quot;Não foi encontrada versão do cliente no {:?}!&quot;, siger_ini))?;
    let versao = VersaoSig::try_from(versao)?;
    Ok(versao)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="convertendo-result-para-option"><a class="header" href="#convertendo-result-para-option">Convertendo <code>Result</code> para <code>Option</code></a></h2>
<p>O contrário também pode ocorrer, quando temos um <code>Result</code> e
pretendemos transformar para <code>Option</code>. Para isso existe o método <code>ok</code> que
que retorna <code>Some(T)</code> se o Result for <code>Ok(T)</code> e retorna <code>None</code>
para qualquer tipo de erro,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let siger_ini = PathBuf::from(&quot;../USR/SIGER.ini&quot;);
let versao = versao_from_siger_ini(&amp;siger_ini)
    .ok()
    .unwrap_or(VersaoSig::des());
<span class="boring">}
</span></code></pre></pre>
<h2 id="exercícios"><a class="header" href="#exercícios">Exercícios</a></h2>
<h3 id="preparação"><a class="header" href="#preparação">Preparação</a></h3>
<p>No diretório <code>c:\fontes\rust</code> crie uma aplicação para conter os exercícios com <code>cargo new exercicios</code>.
Abra o projeto com <code>cd exercicios</code> e <code>code .</code></p>
<p>Alguns exercícios são uma &quot;continuação&quot; do exercício anterior.
Fica a critério de cada um se quiser modificar a função ou copiar a função do exercício anterior para ter um histórico. Ou até se preferir criar um projeto separado.</p>
<p>Se preferir manter o histórico das funções podemos experimentar criar uma função para cada exercício e colocar o atributo <code>#[test]</code> para permitir executarmos de dentro do VSCode:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn exerc_1() {
}

#[test]
fn exerc_2() {
}
<span class="boring">}
</span></code></pre></pre>
<p>No VSCode deve habilitar um botão <code>Run</code> em cima do método.</p>
<h3 id="obervações"><a class="header" href="#obervações">Obervações:</a></h3>
<p>O comando <code>print!</code> (exibição sem quebra de linha) geralmente não faz o <em>flush</em>, então pode não aparecer a mensagem imediatamente. Para isso pode usar <code>stdout().flush()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;Aguardando digitação do usuário: &quot;);
stdout().flush().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>O comando <code>stdin().read_line()</code> retorna <code>enter</code> no final. Para ignorar pode usar <code>trim()</code>.</p>
<h2 id="lista-de-exercícios"><a class="header" href="#lista-de-exercícios">Lista de exercícios</a></h2>
<h3 id="conjunto-de-exercícios-1"><a class="header" href="#conjunto-de-exercícios-1">Conjunto de exercícios 1</a></h3>
<hr />
<ul>
<li>Faça o programa permitir uma entrada de teclado.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut input = String::new();
std::io::stdin().read_line(&amp;mut input).expect(&quot;Failed to read line!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Exiba o conteúdo da variável <code>input</code> na tela através de <code>println!</code>.</p>
<hr />
<ul>
<li>Reduza a chamada ao <code>std::io::stdin</code> fazendo esse <em>import</em> com <code>use</code>. Na rotina deve chamar apenas <code>stdin()</code>. Dica: se digitar <code>stdin();</code> e usar tecla de atalho <code>ctrl+.</code> o <em>language server</em> irá sugerir o <em>import</em> para nós.</li>
</ul>
<hr />
<ul>
<li>Isole o uso da função <code>stdin().read_line</code> numa função nossa chamada <code>read_line()</code> e adapte a chamada para usar a nossa função. Dica: função deve retornar <code>-&gt; String</code> e na última para retornar valor fica só o nome da variável sem <code>return</code>.</li>
</ul>
<hr />
<ul>
<li>Peça para o usuário inserir o nome de login e senha, valide para aceitar somente o usuário <code>admin</code> com uma senha de sua escolha. Dica: <code>if</code>. Se quiser pode usar <code>return</code> para sair da função.</li>
</ul>
<hr />
<ul>
<li>Dê as boas vindas ao usuário, use <code>format!</code> para montar a literal.</li>
</ul>
<hr />
<ul>
<li>Agora além do admin permita informar o seu nome. Dica: <code>||</code>.</li>
</ul>
<hr />
<ul>
<li>Adapte o seu programa para o nome ser aceito com <em>case insensitive</em>. Dica: <code>to_lowercase</code>.</li>
</ul>
<hr />
<ul>
<li>Crie um laço de repetição para aceitar somente o login correto, se informar vazio deve sair da rotina. Dica: <code>loop</code> (equivalente ao <code>while true</code>), <code>break</code>.</li>
</ul>
<hr />
<ul>
<li>Crie uma função para validar o usuário logado, tal como <code>is_valid_login</code>. Passe como parâmetros o usuário e senha informados.
Dicas:
<ul>
<li>Parâmetros devem ser do tipo <code>&amp;str</code>,</li>
<li>Deve retornar <code>-&gt; bool</code>.</li>
<li>Talvez seja necessário passar a variável String por parâmetro informando a referência <code>&amp;</code>, por exemplo <code>funcao(&amp;usuario, &amp;senha)</code>.</li>
</ul>
</li>
</ul>
<h3 id="conjunto-de-exercícios-2"><a class="header" href="#conjunto-de-exercícios-2">Conjunto de exercícios 2</a></h3>
<hr />
<ul>
<li>Vamos deixar de aceitar nome de usuário e vamos aceitar somente números. Se desejar pode criar um novo projeto.</li>
</ul>
<hr />
<ul>
<li>Faça a conversão para numérico, na função <code>main</code> faça algo assim:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let n: u32 = input.parse().expect(&quot;Failed to convert to number&quot;);

<span class="boring">}
</span></code></pre></pre>
<p>Exiba o número em tela.</p>
<hr />
<ul>
<li>Crie uma função para retornar o número digitado pelo usuário (isolar a função acima). Dica: retorno da função vai ser <code>-&gt; u32</code>.</li>
</ul>
<hr />
<ul>
<li>Crie um laço de aceitação para aceitar os números. Se informar <code>0</code> deve interromper.</li>
</ul>
<hr />
<ul>
<li>O programa atual ocorre erro se o usuário não informar um número válido. Ao invés de chamar <code>expect</code> vamos chamar o método <code>unwrap_or</code> e informar o valor <code>0</code>. Ou seja, se o usuário digitar algum valor que não seja numérico irá retornar <code>0</code>.</li>
</ul>
<hr />
<ul>
<li>Armazene os números digitados pelo usuário em vetor. Dicas: <code>Vec::new()</code>, <code>mut</code>.</li>
</ul>
<hr />
<ul>
<li>Exiba lista com os números informados pelo usuário com laço. Dica: <code>for x in</code>.</li>
</ul>
<hr />
<ul>
<li>Ao final da lista exiba o valor da soma total dos elementos do vetor.</li>
</ul>
<hr />
<ul>
<li>Exiba o valor do maior número da lista.</li>
</ul>
<hr />
<ul>
<li>Calcule e exiba o valor da média da lista.</li>
</ul>
<hr />
<ul>
<li>Através de iterator da lista vamos exibir a lista dos números pares.
Dicas:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pares: Vec&lt;_&gt; = v.iter().filter(|n| true).collect();
<span class="boring">}
</span></code></pre></pre>
<p>Para verificar se é par pode fazer <code>n % 2 == 0</code>.</p>
<hr />
<ul>
<li>Faça uma nova lista dobrando o valor de cada elemento. Dica: use <code>map</code> semelhante como foi usado no <code>filter</code>.</li>
</ul>
<hr />
<ul>
<li>Faça uma nova lista com <code>map</code> que se o número for menor que média ele deve ser substituído por zero.
Dicas:
<ul>
<li>Use o <code>if</code> como &quot;expressão&quot; para funcionar como operador ternário, por exemplo <code>if true { u0 } else { *n }</code>.</li>
<li>Provavelmente terá que usar de-referência <code>*</code> no elemento n para poder comparar com a média ou usar a referência <code>&amp;</code> na média.</li>
<li>No <code>if</code> e <code>else</code> devem ter o mesmo retorno, talvez ambos devem ser <code>owned</code> T ao invés de <code>borrowed</code> &amp;T.</li>
</ul>
</li>
</ul>
<hr />
<p>A nossa função de retornar o número digitado pelo usuário usa o <code>0</code> como identificar de &quot;fim&quot;.
Vamos mudar a nossa função para retornar um <code>Option&lt;u32&gt;</code>. Ao invés do <code>unwrap_or</code> faça assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result =
    match input.parse() {
        Ok(n) =&gt; Some(n),
        Err(_) =&gt; None,
    };
result
<span class="boring">}
</span></code></pre></pre>
<p>No laço de chamada troque por <code>while let Some(n) = read_num() {</code>.
Isso permitirá um laço bem elegante que só executa enquanto houver número válido informado.</p>
<h3 id="conjunto-de-exercícios-3"><a class="header" href="#conjunto-de-exercícios-3">Conjunto de exercícios 3</a></h3>
<hr />
<ul>
<li>Crie struct Produto, com campos código, descrição, ativo (bool) e valor.</li>
</ul>
<hr />
<ul>
<li>Crie um construtor <code>new</code> passando os campos necessários. O campo ativo pode assumir <em>default</em> <code>true</code> (não passar como parâmetro no construtor).</li>
</ul>
<hr />
<ul>
<li>Crie <em>getter</em> para os campos. Dicas: nos <em>getter</em> o primeiro parâmetro é <code>&amp;self</code>, não possui prefixo <code>get_</code>, fica somente por exemplo <code>codigo(&amp;self)</code>. Exceto para campo <code>bool</code> que deve ter <code>is_</code>.</li>
</ul>
<hr />
<ul>
<li>Crie <em>setter</em> para os campos. Dicas: o primeiro parâmetro é <code>&amp;mut self</code>. Deve ter prefixo <code>set_</code>. Para tipo de campo que não permite <code>copy</code> implícito faça <code>.clone()</code></li>
</ul>
<hr />
<ul>
<li>Vamos simular uma aplicação de venda. Vamos criar <em>structs</em> para cliente, pedido e item de pedido.
Nos <em>structs</em> adicione o atributo <code>#[derive(Clone)]</code> para permitir os nossos <em>structs</em> terem o método <code>clone()</code>.
O pedido deve ter um método <code>add_item</code> para permitir arma</li>
</ul>
<h1 id="cli-structopt"><a class="header" href="#cli-structopt">CLI structopt</a></h1>
<h2 id="introdução-1"><a class="header" href="#introdução-1">Introdução</a></h2>
<p>Para criarmos aplicações CLI (linha de comando) iremos usar o <code>structopt</code>,
que facilita muito nessa tarefa, com a vantagem que temos que somente
declarar a estrutura de parâmetros e comandos.
Em conjunto com ele iremos usar o <code>paw</code>, que permite o método <code>main</code> receber
os parâmetros <code>args: Args</code> semelhante como em outras linguagens.</p>
<p>Vamos inserir as dependências no <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
paw = &quot;1.0&quot;
structopt = { version = &quot;0.3&quot;, features = [&quot;paw&quot;] }
</code></pre>
<h2 id="parâmetros-posicionais"><a class="header" href="#parâmetros-posicionais">Parâmetros posicionais</a></h2>
<p>No <code>main.rs</code> devemos declarar os comandos e parâmetros em um <code>struct</code>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use structopt::StructOpt;

#[derive(StructOpt)]
#[structopt(name = &quot;example&quot;, about = &quot;Aplicação teste de command line&quot;)]
struct Args {
    /// Versão que deve processar
    versao: String,
    /// Arquivo para carregar
    arquivo: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe que no topo do <em>struct</em> foi adicionado <code>#[derive(StructOpt)]</code> e também possui um <code>#[structopt]</code>.
Esse último atributo permite definir o nome a e descrição para o aplicativo CLI.</p>
<p>A definição dessa estrutura já irá montar o nosso <em>help</em> automaticamente, onde pode ser chamado pelo parâmetro <code>--help</code>.
Os campos possuem comentários com <code>///</code>, que já servem como <em>help</em> do parâmetro ou comando.</p>
<p>Para acessarmos os parâmetros devemos fazer da seguinte forma:</p>
<pre><pre class="playground"><code class="language-rust">#[paw::main]
fn main(args: Args) {
    println!(
        &quot;versão: {:?} arquivo: {:?}&quot;,
        args.versao, args.arquivo
    );
}
</code></pre></pre>
<p>Observe no <code>main</code> possui o atributo <code>#[paw::main]</code> e que recebe o parâmetro <code>args: Args</code>.
Mas o <code>args</code> não é <em>array</em> de <em>strings</em>, e sim é nossa própria estrutura de parâmetros já preenchida.</p>
<p><strong>Se o usuário não informar os parâmetros esperados nem irá executar o método <code>main</code>.</strong>
Isso também inclui a validação do formato do parâmetro, por exemplo,
se definimos um parâmetro numérico <code>u32</code> e o usuário informou <code>String</code>.
<strong>Esses tipos de validações simplificam muito o desenvolvimento da aplicação.</strong></p>
<p>Nesse exemplo acima os parâmetros são <strong>posicionais</strong>, ou seja, eles dependem da ordem da posição em que foram definidos.</p>
<h2 id="passar-parâmetros-pelo-cargo"><a class="header" href="#passar-parâmetros-pelo-cargo">Passar parâmetros pelo cargo</a></h2>
<p>Quando executamos <code>cargo run</code> ele executa o programa sem passar os parâmetros para o nosso programa.
Para passarmos parâmetros devemos fazer <code>cargo run -- &lt;parâmetros do nosso programa&gt;</code>.
Esses <code>--</code> servem para delimitar que não é parâmetro do <code>cargo</code>. Por exemplo:</p>
<pre><code>cargo run -- 20.20a arquivo.txt
</code></pre>
<p>Para exibir o help do nosso programa podemos fazer:</p>
<pre><code>cargo run -- --help
</code></pre>
<h2 id="parâmetros-nomeados"><a class="header" href="#parâmetros-nomeados">Parâmetros nomeados</a></h2>
<p>Outra forma de definir parâmetros são os <strong>nomeados</strong>.
Nesse caso os parâmetros devem ter o nome indicado antes do valor,
além que podem ter uma forma longa, tal como <code>--parametro</code> ou curta <code>-p</code>.
Vamos adaptar o programa anterior:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(StructOpt)]
#[structopt(name = &quot;example&quot;, about = &quot;Aplicação teste de command line&quot;)]
struct Args {
    /// Versão que deve processar
    #[structopt(short, long)]
    versao: String,
    /// Arquivo para carregar
    #[structopt(short, long)]
    arquivo: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe que agora cada campo possui o atributo <code>#[structopt]</code>.
Perceba que são passados <code>short</code> e <code>long</code> como modificadores do atributo.
Isso indica que o parâmetro permitir nomes curto e longo.</p>
<p>Também existe o modificador <code>default_value</code>, que pode definir um valor <em>default</em>, caso o usuário não informar o parâmetro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Versão que deve processar
#[structopt(short, long, default_value = &quot;des&quot;)]
versao: String,
<span class="boring">}
</span></code></pre></pre>
<h3 id="parâmetros-switch"><a class="header" href="#parâmetros-switch">Parâmetros <em>switch</em></a></h3>
<p>Se definimos um parâmetro como <code>bool</code> ele acaba funcionando como um <em>switch</em> (<em>flag</em>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Activate debug mode
#[structopt(short, long)]
debug: bool,
<span class="boring">}
</span></code></pre></pre>
<h3 id="parâmetros-opcionais"><a class="header" href="#parâmetros-opcionais">Parâmetros opcionais</a></h3>
<p>Se definimos um parâmetro como <code>Option</code> ele fica com comportamento de opcional (o usuário não precisa informar)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// Output file, stdout if not present
#[structopt(short, long)]
output: Option&lt;String&gt;,
<span class="boring">}
</span></code></pre></pre>
<h3 id="observações"><a class="header" href="#observações">Observações</a></h3>
<p>Observe que podemos misturar parâmetros posicionais com nomeados. Isso permite construirmos algo como <code>grep -i texto arquivo.txt</code>.</p>
<h2 id="comandos-e-sub-comandos"><a class="header" href="#comandos-e-sub-comandos">Comandos e sub-comandos</a></h2>
<p>Podemos criar &quot;comandos&quot; de forma que cada comando tenha seus próprios parâmetros.
Para isso devemos que declarar um <code>enum</code> para conter os comando e definir o atributo <code>#[structopt(subcommand)]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use structopt::StructOpt;
</span>
#[derive(StructOpt)]
#[structopt(name = &quot;example&quot;, about = &quot;An example of StructOpt usage.&quot;)]
struct Args {
    /// Activate debug mode, short and long flags (-d, --debug) will be deduced from the field's name
    #[structopt(short, long)]
    debug: bool,
    /// Version
    #[structopt(short, long)]
    version: String,
    #[structopt(subcommand)]
    command: Command,
}

#[derive(StructOpt)]
enum Command {
    List {},
    Add {
        /// Description (posicional field)
        description: String,
        /// Abbreviation (argumented and optional)
        #[structopt(short, long)]
        abbreviation: Option&lt;String&gt;,
    },
    Done {
        /// Id (posicional field)
        id: i64,
    },
}
<span class="boring">}
</span></code></pre></pre>
<p>No exemplo acima o nosso programa vai ter os comandos <em>list</em>, <em>add</em> e <em>done</em>. Observe que cada comando teu os seus próprios parâmetros.</p>
<p>Na execução da rotina podemos fazer um <code>match</code> para os comandos:</p>
<pre><pre class="playground"><code class="language-rust">#[paw::main]
fn main(args: Args) {
    println!(
        &quot;debug: {} versão: {:?}&quot;,
        args.debug, args.version,
    );
    match args.command {
        Command::List {} =&gt; {
            list();
        }
        Command::Add {
            description,
            abbreviation,
        } =&gt; {
            add(description, abbreviation);
        }
        Command::Done { id } =&gt; {
            done(id);
        }
    }
}
</code></pre></pre>
<p>Observe que os parâmetros de cada comando são &quot;declarados&quot; dentro do bloco do <code>match</code>.
Assim como alguns parâmetros são exclusivos de cada comando (declarado no <em>enum</em>), podemos ter parâmetros &quot;globais&quot; (declarados no <em>struct</em>)</p>
<h2 id="exercícios-1"><a class="header" href="#exercícios-1">Exercícios</a></h2>
<ul>
<li>
<p>Modifique o exercício de aceitar usuário/senha.</p>
<ul>
<li>Permita o programa informar usuário/senha por linha de comando, ao invés de aceitar de forma interativa. Se não informar nada mantenha o comportamento original.</li>
</ul>
</li>
<li>
<p>Modifique o exercício de aceitar elementos numéricos.</p>
<ul>
<li>Permita o programa informar os elementos por linha de comando, ao invés de aceitar de forma interativa. Se não informar nada mantenha o comportamento original. Dica: pode definir parâmetro como <code>Vec</code>.</li>
</ul>
</li>
<li>
<p>Quem terminar pode criar um programa para fazer uma espécie de TODO list, que permita comandos de adicionar, listar e marcar como realizado.</p>
</li>
</ul>
<h1 id="manipulação-json"><a class="header" href="#manipulação-json">Manipulação JSON</a></h1>
<h2 id="dependência"><a class="header" href="#dependência">Dependência</a></h2>
<p>Para manipular tipo de dados <em>json</em> usaremos a lib <code>serde</code> (<strong>ser</strong>ializer/<strong>de</strong>serializer).
O <code>serde</code> permite serializar objetos para diversos formatos (json, toml, yaml, avro...),
porém existem dependências separadas para cada formato. Por isso devemos adicionar as depdências <code>serde</code> (core) e <code>serde_json</code> (formato json) no arquivo <code>Cargo.toml</code>:</p>
<pre><code>serde = {version = &quot;1.0&quot;, features = [&quot;derive&quot;]}
serde_json = &quot;1.0&quot;
</code></pre>
<p>Observe que ao adicionar o <code>serde</code> usamos uma forma diferente, onde indicamos o <code>features</code>.
Esta é uma forma para algumas bibliotecas permitirem dividir funcionalidades,
para diminuir tempo de compilação e tamanho do executável.
O recurso <code>derive</code> é para permitir definir atributo para serializar <em>structs</em>.</p>
<h2 id="declarar-tipo-de-objsto-json"><a class="header" href="#declarar-tipo-de-objsto-json">Declarar tipo de objsto json</a></h2>
<p>O <code>serde</code> possui a macro <code>json!</code> que permite definir um arquivo <em>json</em>
exatamente do formato textual. Também é possível assumir valores a partir de variáveis e expressões:</p>
<pre><pre class="playground"><code class="language-rust">use serde_json::json;

fn main() {
    {
        let value = json!({
            &quot;code&quot;: 200,
            &quot;success&quot;: true,
            &quot;payload&quot;: {
                &quot;features&quot;: [
                    &quot;serde&quot;,
                    &quot;json&quot;
                ]
            }
        });
        println!(&quot;{}&quot;, value);
    }

    {
        let code = 200;
        let features = vec![&quot;serde&quot;, &quot;json&quot;];
        let value = json!({
            &quot;code&quot;: code,
            &quot;success&quot;: code == 200,
            &quot;payload&quot;: {
                features[0]: features[1]
            }
        });
        println!(&quot;{}&quot;, value);
    }
}
</code></pre></pre>
<h2 id="acessar-atributos-de-forma-dinâmica"><a class="header" href="#acessar-atributos-de-forma-dinâmica">Acessar atributos de forma dinâmica</a></h2>
<p>Eventualmente poderemos precisar acessar atributos pelo nome.
Para isso podemos usar o tipo <code>Value</code> e a função <code>from_str</code>:</p>
<pre><pre class="playground"><code class="language-rust">use serde_json::Value;
use serde_json::from_str;

fn main() {
    let data = r#&quot;
        {
            &quot;name&quot;: &quot;John Doe&quot;,
            &quot;age&quot;: 43,
            &quot;phones&quot;: [
                &quot;+44 1234567&quot;,
                &quot;+44 2345678&quot;
            ]
        }&quot;#;

    // Parse the string of data into serde_json::Value.
    let v: Value = from_str(&amp;data).unwrap();

    // Access parts of the data by indexing with square brackets.
    println!(&quot;Please call {} at the number {}&quot;, v[&quot;name&quot;], v[&quot;phones&quot;][0]);

}
</code></pre></pre>
<p>Também é possível desserializar o json em <em>map</em>:</p>
<pre><pre class="playground"><code class="language-rust">let map = HashMap&lt;String, Value&gt; = from_str(&amp;data).unwrap();
```

# Serializando e desserializando *structs*
Para tornar um objeto serializável devemos definir os seguintes atributos no topo do `struct`:

```rust
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct ObjetoJson {
    pub id: u32,
    pub name: String,
}
```

Para serializar objeto em *string*:
```rust

let var_string = serde_json::to_string(&amp;objeto_json).unwrap();
```

Para desserializar objeto a partir de *string*:
```rust
let objeto_json: ObjetoJson = serde_json::from_str(&amp;var_string).unwrap();
```

Também é possível desserializar objeto usando a notação do *turbo fish* `::&lt;&gt;`:
```rust
let objeto_json = serde_json::from_str::&lt;ObjetoJson&gt;(&amp;var_string).unwrap();
```

Exemplo completo:

```rust
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct Groups {
    groups: Vec&lt;Group&gt;
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Group {
    pub id: u32,
    pub name: String,
}

fn main() {
    // Serializar objeto em string
    let groups_s;
    {
        let group_a = Group {
            id: 1,
            name: String::from(&quot;Group A&quot;),
        };
        let group_b = Group {
            id: 2,
            name: String::from(&quot;Group B&quot;),
        };
        let group_c = Group {
            id: 3,
            name: String::from(&quot;Group C&quot;),
        };

        let groups = Groups { groups: vec![group_a, group_b, group_c] };

        groups_s = serde_json::to_string(&amp;groups).unwrap();
    }


    // Desserializar objeto a partir de string
    let groups = serde_json::from_str::&lt;Groups&gt;(&amp;groups_s).unwrap();
    println!(&quot;{:?}&quot;, groups);

}
```
## Formatação com quebra de linha
Por padrão quando fazemos uma desserialização por `serde_json::to_string` o conteúdo fica todo em uma linha.
Quando temos uma estrutura grande pode ficar difícil de ler. Para obtermos um string com quebra de linha e fácil
entendimento humana usamos o `serde_json::to_string_pretty`:

```rust
let value = json!({
    &quot;code&quot;: 200,
    &quot;success&quot;: true,
    });
let s = serde_json::to_string_pretty(&amp;value).unwrap();
println!(&quot;{}&quot;, s);
```

## Ferramenta para gerar *struct* a partir de string json
Isso é útil, por exemplo, quando pretendemos interagir com alguma API com os tipos *json* já definidos.

Podemos usar a ferramenta [transform.tools/json-to-rust-serde](https://transform.tools/json-to-rust-serde)

Este site permite colocar o *json* e ele gera o *struct* Rust.

É necessário ajustar a dependência para a versão mais recente do serde (trocar `serde_derive::` para `serde::`).
Deve ficar:

```rust
use serde::{Serialize, Deserialize};

```
# Exercícios

Pratique as três formas apresentadas para trabalhar com json:

* `json!`
* `Value` + `from_str`
* `#[derive(Serialize, Deserialize)]` (`serde_json::to_string`  `serde_json::from_str`)

---
Aplique a serialização de *json* para os *structs* do exercício de vendas (produto, cliente, pedido e item).

---
Vamos preparar o nosso aplicativo de vendas para ler e gravar dados. Crie objetos *ProdutoRepository*, *ClienteRepository*, etc. Esses objetos deve ter um método `load(codigo: u32)` que deve receber o código e deve retornar `Result&lt;Cliente, String&gt;`, por exemplo. Moque alguns registros praticando o uso do `json!`.
Dica: a rotina pode ser algo como:

```rust
if codigo == 1 {
    let cliente =
        serde_json::from_str::&lt;Cliente&gt;(
            json!(
                &quot;codigo&quot;: codigo,
                &quot;nome&quot;: &quot;Nome&quot;,
            )
        );
    Ok(cliente)
} else {
    Err(format!(&quot;Registro de código {} não encontrado!&quot;, codigo))
}
```
</code></pre></pre>
<h1 id="leitura-e-gravação-de-arquivos"><a class="header" href="#leitura-e-gravação-de-arquivos">Leitura e gravação de arquivos</a></h1>
<h2 id="objetos-path-e-pathbuf"><a class="header" href="#objetos-path-e-pathbuf">Objetos <code>Path</code> e <code>PathBuf</code></a></h2>
<p>Em Rust existe o objeto <code>PathBuf</code>, semelhante como em Java existe o objeto <code>File</code> (ou <code>Path</code> na API mais moderna).
Esse tipo de objeto tem como objetivo representar um arquivo, não necessariamente o seu conteúdo.</p>
<p>Além do <code>PathBuf</code> existe o <code>Path</code>. A diferença entre os dois é semelhante como em outras estruturas
dinâmicas que possuem sua versão &quot;<em>slice</em>&quot; (referência que pode representar um objeto na <em>stack</em> ou <em>heap</em>) e a versão &quot;<em>owned</em>&quot;.</p>
<p><code>Path</code> é a versão de referência e <code>PathBuf</code> é a sua versão <em>owned</em>.</p>
<p>Podemos montar uma tabela para fazermos uma associação mental:</p>
<table><thead><tr><th>Reference</th><th>Owned</th></tr></thead><tbody>
<tr><td><code>&amp;str</code></td><td><code>String</code></td></tr>
<tr><td><code>&amp;[]</code></td><td><code>Vec</code></td></tr>
<tr><td><code>Path</code></td><td><code>PathBuf</code></td></tr>
</tbody></table>
<p>Isso significa que <code>PathBuf</code> pode ser mutável e podemos declarar campos com esse tipo.
<code>Path</code> por sua vez é uma referência, devemos usar ele quando funciona como uma literal
&quot;constante&quot; ou quando representa o parâmetro de uma função.</p>
<blockquote>
<p>Significa que o tipo que mais iremos trabalhar é o <code>PathBuf</code>.</p>
</blockquote>
<p>Podemos converter um para outro. O <code>Path</code> possui o método <code>to_path_buf()</code> e o <code>PathBuf</code>
possui o método <code>as_path()</code>.</p>
<p>Para usar esses tipos devemos fazer um dos <em>imports</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
use std::path::PathBuf;
<span class="boring">}
</span></code></pre></pre>
<p>Para criar um objeto <code>Path</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = Path::new(&quot;foo.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Para criar um objeto <code>PathBuf</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = PathBuf::from(&quot;foo.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="tipos-osstr-e-osstring"><a class="header" href="#tipos-osstr-e-osstring">Tipos <code>OsStr</code> e <code>OsString</code></a></h2>
<p>Rust é bastante rigoroso sobre a questão de acesso a <em>strings</em> do sistema operacional,
principalmente para acesso via API (que indiretamente acesso dos arquivos utilizam).
Em Linux, por exemplo, <em>strings</em> possuem encoding UTF-8 enquanto no Windows é UTF-16 (dois bytes).</p>
<p>Nem todos caracteres válidos de <em>string</em> do sistema operacial são caracteres válidos do tipo <code>String</code>.
Então devido a essa questão existem tipos específicos para representar <em>strings</em> do sistema operaiconal: <code>OsStr</code> (<em>reference</em>) e <code>OsString</code> (<em>owned</em>).</p>
<blockquote>
<p>Uma <code>String</code> pode ser convertida para <code>OsString</code>, mas o contrário nem sempre é possível.</p>
</blockquote>
<p>Podemos fazer a conversão para <code>String</code> com o método <code>to_string_lossy</code>,
que ignora qualquer incompatibilidade de caracteres. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = PathBuf::from(&quot;foo.txt&quot;);
assert_eq!(path.to_string_lossy(), &quot;foo.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Dificilmente iremos declarar uma variável como <code>OsString</code>, geralmente trabalharemos com os tipo <code>String</code> e <code>&amp;str</code>.</p>
</blockquote>
<p>Muitas funções permitem passar parâmetros como <code>OsString</code>, <code>String</code> e <code>PathBuf</code> de forma transparente.</p>
<h2 id="formato-de-barras"><a class="header" href="#formato-de-barras">Formato de barras</a></h2>
<p>Sobre o formato de barras de separador de diretório, Rust funciona semelhante como no Java e Ruby,
no sentido que podemos trabalhar com barras Unix <code>/</code> mesmo quando executando em Windows.
Porém o contrário não é verdadeiro, se usarmos barra Windows <code>\</code> no Linux não funciona.
Então podemos considerar que usar barras Unix é o mais conveniente.</p>
<p>Vale lembrar que podemos usar <em>raw string</em> para criar arquivos com contra barras.
Por exemplo, isso:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathBuf::from(&quot;C:\\TEMP\\arquivo.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Pode ser representado como:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PathBuf::from(r&quot;C:\TEMP\arquivo.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="funções-do-pathbuf"><a class="header" href="#funções-do-pathbuf">Funções do <code>PathBuf</code></a></h2>
<p>Em geral <code>PathBuf</code> serve para representar um arquivo ou diretório.</p>
<p>Podemos verificar se o arquivo existe pelo método <code>exists()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(!PathBuf::from(&quot;does_not_exist.txt&quot;).exists());
<span class="boring">}
</span></code></pre></pre>
<p>Para verificar se é diretório ou arquivo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(PathBuf::from(&quot;./is_a_directory/&quot;).is_dir(), true);
<span class="boring">}
</span></code></pre></pre>
<p>Depois veremos como obter mais metadados dos arquivos.</p>
<p>O objeto <code>PathBuf</code> permite manipular partes da via.</p>
<p>Por exemplo, concatenar partes de diretórios e arquivos com <code>join</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(PathBuf::from(&quot;/etc&quot;).join(&quot;passwd&quot;), PathBuf::from(&quot;/etc/passwd&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Obter a extensão do arquivo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(&quot;rs&quot;, PathBuf::from(&quot;foo.rs&quot;).extension().unwrap());
<span class="boring">}
</span></code></pre></pre>
<p>Obter o diretório pai do arquivo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let path = PathBuf::from(&quot;/foo/bar&quot;);
let parent = path.parent().unwrap();
assert_eq!(parent, Path::new(&quot;/foo&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Obter o nome do arquivo do arquivo (última parte):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(Some(OsStr::new(&quot;bin&quot;)), PathBuf::from(&quot;/usr/bin/&quot;).file_name());
<span class="boring">}
</span></code></pre></pre>
<h2 id="operações-com-arquivos"><a class="header" href="#operações-com-arquivos">Operações com arquivos</a></h2>
<p>Para fazer operações com arquivos devemos usar as funções do pacote com <code>use std::fs</code>.</p>
<p>Deletar arquivo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs::remove_file(&quot;a.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Copiar arquivo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs::copy(&quot;foo.txt&quot;, &quot;bar.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Mover/renomear arquivo</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fs::rename(&quot;a.txt&quot;, &quot;b.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2 id="informações-de-arquivos-metadados"><a class="header" href="#informações-de-arquivos-metadados">Informações de arquivos (metadados)</a></h2>
<p>Para acessarmos informações de arquivos (tamanho, data/hora, etc) podemos acessar o objeto de metadados:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let metadata = fs::metadata(&quot;foo.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Exemplo para acessar data de modificação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Ok(time) = metadata.modified() {
    println!(&quot;{:?}&quot;, time);
} else {
    println!(&quot;Not supported on this platform&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Além da data de modificação <code>modified</code>, existe a função para data de último acesso <code>accessed</code> e data de criação <code>created</code>.</p>
<p>Para obter o tamanho do arquivo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let file_size = fs::metadata(&quot;some_file&quot;).unwrap().size();
<span class="boring">}
</span></code></pre></pre>
<p>Para verificar se arquivo é <em>read only</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let is_readonly = fs::metadata(&quot;foo.txt&quot;).unwrap().permissions().readonly();
<span class="boring">}
</span></code></pre></pre>
<h2 id="ler-e-gravar-conteúdo-de-arquivo"><a class="header" href="#ler-e-gravar-conteúdo-de-arquivo">Ler e gravar conteúdo de arquivo</a></h2>
<p>Foram criadas rotinas utilitárias para manipular arquivos na Rech. Um dos motivos para termos as nossas próprias rotinas foi simplificar o uso e adaptar para nossas necessidades. Por exemplo, a rotina de leitura de txt possui inteligência para detectar automaticamente o encoding UTF-8 ou Windows-1252.</p>
<p>Mais detalhes em:
<a href="http://gitlab.rechinfo.local/gitlab/rech/rust/ri-lib-file-utils">http://gitlab.rechinfo.local/gitlab/rech/rust/ri-lib-file-utils</a></p>
<p>Devemos inserir a dependência:</p>
<pre><code class="language-ini">[dependencies]
ri-lib-file-utils = {git = &quot;http://gitlab.rechinfo.local/gitlab/rech/rust/ri-lib-file-utils.git&quot;}
</code></pre>
<p>Rust possui um recurso legal que podemos aplicar <em>traits</em> (interfaces) para tipos nativos.
Então podemos adicionar métodos de leitura e gravação ao tipo <code>PathBuf</code>.</p>
<p>Exemplo de como ler conteúdo de arquivo txt com o método <code>reader</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ri_lib_file_utils::file_reader::PathReader;
let content = PathBuf::from(&quot;arquivo.txt&quot;).reader().load_str().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Exemplo de como ler gravar de arquivo txt com o método <code>writer</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ri_lib_file_utils::file_writer::PathWriter;
PathBuf::from(&quot;arquivo.txt&quot;).writer().write(&quot;conteúdo teste&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<h2 id="exercícios-2"><a class="header" href="#exercícios-2">Exercícios</a></h2>
<p>Vamos adaptar o nosso programa de venda para persistir dados, ou seja, ler e gravar.
O objeto <code>ProdutoRepository</code>, por exemplo, poderá carregar a lista de produtos na sua criação.
Quando for usado o método <code>save()</code> pode gravar a lista de produtos atualizados.</p>
<p>Para isso pode usar os métodos <code>serde_json::from_str</code> e <code>serde_json::to_string</code>,
em conjunto com as funções de ler e gravar arquivo acima.</p>
<h2 id="tipos-date-time"><a class="header" href="#tipos-date-time">Tipos <em>date time</em></a></h2>
<h3 id="biblioteca-chrono"><a class="header" href="#biblioteca-chrono">Biblioteca chrono</a></h3>
<p>Rust não possui um tipo nativo para trabalhar com data/hora.
Para trabalharmos com esses tipos vamos usar a lib <code>chrono</code>. Devemos inserir no <code>Cargo.toml</code> a dependência:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>chrono = &quot;0.4&quot;
<span class="boring">}
</span></code></pre></pre>
<p>Se for necessário persistir atributo json, deve adicionar a feature <code>serde</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>chrono = { version = &quot;0.4&quot;, features = [&quot;serde&quot;] }
<span class="boring">}
</span></code></pre></pre>
<p>A API do <code>chrono</code> é relativamente extensa, então vale a pena conferir a documentação em:</p>
<p><a href="https://github.com/chronotope/chrono">https://github.com/chronotope/chrono</a></p>
<p><a href="https://docs.rs/chrono/0.4.19/chrono/index.html">https://docs.rs/chrono/0.4.19/chrono/index.html</a></p>
<h2 id="tipos-date-time-1"><a class="header" href="#tipos-date-time-1">Tipos <em>date time</em></a></h2>
<p>O chrono possui tipos que são sensíveis ao <em>time zone</em> e outros que não são (<em>naive</em>). Pode ser comum termos que intercambiar e converter entre esses tipos.</p>
<h2 id="tipos-date-time-com-time-zone"><a class="header" href="#tipos-date-time-com-time-zone">Tipos <em>date time</em> com <em>time zone</em></a></h2>
<p>O tipos que possuem informação de <em>time zone</em> são:</p>
<ul>
<li><code>Date&lt;Tz&gt;</code></li>
<li><code>DateTime&lt;Tz&gt;</code></li>
</ul>
<p>Observe que esses tipo permitem informar via <em>generics</em> a <em>trait</em> (interface) que define o <em>time zone</em>, que é <code>Tz: TimeZone</code>.</p>
<p>As implementações que mais usaremos é:</p>
<ul>
<li><code>Utc</code></li>
<li><code>Local</code></li>
</ul>
<p>Um exemplo para instanciar a data/hora atual considerando o <em>time zone</em> local:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let local_now: DateTime&lt;Local&gt; = Local::now();
<span class="boring">}
</span></code></pre></pre>
<p>A forma acima era com tipagem explícita, com a inferência de tipo fica.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let local_now = Local::now();
<span class="boring">}
</span></code></pre></pre>
<p>Observe que nós instanciamos o tipo <code>DateTime</code> a partir do <code>TimeZone</code>, e não a partir do <code>DateTime</code>.</p>
<h2 id="tipos-date-time-sem-time-zone-naive"><a class="header" href="#tipos-date-time-sem-time-zone-naive">Tipos <em>date time</em> sem <em>time zone</em> (<em>naive</em>)</a></h2>
<ul>
<li><code>NaiveDate</code></li>
<li><code>NaiveDateTime</code></li>
</ul>
<p>Exemplo para criar um <code>NaiveDateTime</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let date = NaiveDate::from_ymd(2021, 12, 31);
<span class="boring">}
</span></code></pre></pre>
<p>Observação: os tipos <em>naive</em>, não possuem <code>now()</code> ou <code>today()</code>, para criar a partir do <em>time zone</em> <code>Utc</code> ou <code>Local</code> e converter para <em>naive</em>.</p>
<h3 id="tipo-duration"><a class="header" href="#tipo-duration">Tipo <em>Duration</em></a></h3>
<p>O tipo <em>Duration</em> representa a duração entre duas data/hora.
Esse tipo pode ser convertido a partir de número de milli-segundos, segundos, minutos, horas e dias.
E também possui métodos para retornar essa informação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let d = Duration::hours(24);

assert_eq!(diff.num_days(), 1);
<span class="boring">}
</span></code></pre></pre>
<p>Podemos obter a duração entre dois <em>date/time</em> realizando operação simples de subtração:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let diff: Duration = end_date_time - start_date_time;
<span class="boring">}
</span></code></pre></pre>
<p>E também podemos obter uma nova data somando uma duração sobre outro data:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let end_date_time = start_date_time + Duration::hours(24);
<span class="boring">}
</span></code></pre></pre>
<h3 id="operações-diversas"><a class="header" href="#operações-diversas">Operações diversas</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    use chrono::{DateTime, Datelike, Duration, Local, NaiveDate, TimeZone, Utc};

    let utc_now: DateTime&lt;Utc&gt; = Utc::now();
    let local_now: DateTime&lt;Local&gt; = Local::now();

    // Convert DateTime to naive
    let naive_utc = utc_now.naive_utc();
    let naive_local = local_now.naive_local();

    // Convert naive to DateTime
    assert_eq!(utc_now, Utc.from_utc_datetime(&amp;naive_utc));
    assert_eq!(local_now, Local.from_local_datetime(&amp;naive_local).unwrap());

    // Create Naive from parts
    let n = NaiveDate::from_ymd(2021, 12, 31);
    println!(&quot;NaiveDate: {}&quot;, n);

    // DateTime&lt;Local&gt; from parts
    let mut d = Local.ymd(2014, 7, 8).and_hms(15, 0, 0);

    // Date parts
    assert_eq!(naive_utc.year(), utc_now.year());

    // Change year part
    d = d.with_year(2021).unwrap();
    assert_eq!(d.year(), 2021);

    // Add Duration and get a new Date
    let next_week = d + Duration::days(7);
    println!(&quot;next_week: {}&quot;, next_week);

    // Subtract a Date and get a Duration
    let diff = naive_utc - naive_local;
    println!(&quot;days: {}&quot;, diff.num_days());

    // Parser
    let date_utc = Utc
        .datetime_from_str(&quot;2014-11-28 12:00:09&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)
        .unwrap();
    println!(&quot;date_utc: {}&quot;, date_utc);

    // formatting and parsing specifiers:
    // https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html#specifiers

    // Parser ISO 8601
    let date_off_set = DateTime::parse_from_rfc3339(&quot;2014-11-28T21:00:09+09:00&quot;).unwrap();
    println!(&quot;date_off_set: {}&quot;, date_off_set);

    // Format
    println!(
        &quot;formatted: {}&quot;,
        date_off_set.format(&quot;%Y-%m-%d %H:%M:%S&quot;).to_string()
    );
}
</code></pre></pre>
<h3 id="exercícios-3"><a class="header" href="#exercícios-3">Exercícios</a></h3>
<p>Faça experimentos com as funções acima.</p>
<p>No exercício anterior para de vendas (cadastro de produto e cliente), crie campos de <em>Date</em>.
Para permitir persistir json terá que fazer o import <code>chrono = { version = &quot;0.4&quot;, features = [&quot;serde&quot;] }</code>.</p>
<p>Crie um função <code>info(texto: &amp;str)</code> para exibir informações de <em>output</em> como se fosse <em>trace</em>, informando a data/hora no início de cada linha, no formato <code>YYYY-MM-DD HH:MM:SS</code>.</p>
<h2 id="smart-pointers"><a class="header" href="#smart-pointers"><em>Smart pointers</em></a></h2>
<p>Em Rust os ponteiros são tratados como referências, pelo símbolo <code>&amp;</code>.</p>
<p><em>Smart pointers</em> são estruturas que podem funcionar como ponteiros e adicionar algumas funcionalidades.</p>
<blockquote>
<p>Em geral <em>smart pointers</em> são utilizados para <strong>flexibilizar regras</strong> do compilador.</p>
</blockquote>
<p>Os <em>smart pointers</em> funcionam como um &quot;<em>container</em>&quot; (ou <strong>adapter</strong>), ou seja, um objeto que encapsula outra.
É possível acessar o objeto interno por de-referência, através do caractere <code>*</code>.</p>
<p>A seguir vamos ver os principais <em>smart pointers</em>.</p>
<h2 id="boxt-área-na-heap"><a class="header" href="#boxt-área-na-heap"><code>Box&lt;T&gt;</code> (área na <em>heap</em>)</a></h2>
<p>A estrutura <code>Box</code> serve para representar a referência a um dado de <strong>tamanho desconhecido</strong>, ou seja, que será obrigatoriamente alocado na <em>heap</em>.</p>
<p>Na prática ele é mais utilizado para permitir estruturas recursivas e referências a <em>traits</em> (interfaces).</p>
<p>O exemplo abaixo possui a estrutura <code>Node</code> que é recursiva, pois pode conter um campo opcional para representar o objeto pai, que possui mesmo tipo. Esse campo deve ser armazenado como <code>Box&lt;Node&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::path::PathBuf;

#[derive(Debug, Clone)]
struct Node {
    path: PathBuf,
    parent: Option&lt;Box&lt;Node&gt;&gt;,
}

impl Node {
    pub fn new(path: PathBuf) -&gt; Node {
        Self { path, parent: None }
    }

    pub fn add_child(parent: &amp;Node, path: PathBuf) -&gt; Self {
        let parent_box = Box::new(parent.clone());  // &lt;- Criando Box
        Self {
            path,
            parent: Some(parent_box),
        }
    }
}

fn main() {
    let node_parent = Node::new(PathBuf::from(&quot;C:\\&quot;));

    let node_child = Node::add_child(&amp;node_parent, PathBuf::from(&quot;TEMP&quot;));

    println!(&quot;Parent: {:?}&quot;, node_parent);
    println!(&quot;Child: {:?}&quot;, node_child);

    if let Some(parent) = node_child.parent {
        let n = &amp;*parent; // &lt;- Acessar objeto original
        println!(&quot;Parent: {:?}&quot;, n);
    }
}
</code></pre></pre>
<p>Observe que o objeto <code>Node</code> pai é clonado. Isso significa, que no exemplo acima, foram criados 3 objetos.
Para estruturas pequenas isso não é problema, mas caso contrário seria interessante haver uma referência ao objeto pai.
A seguir vamos ver como fazer isso.</p>
<h2 id="rct-reference-count"><a class="header" href="#rct-reference-count"><code>Rc&lt;T&gt;</code> (<em>reference count</em>)</a></h2>
<p>A estrutura <code>Rc</code> serve para fazer um contador de referência a um objeto, fazendo com que o objeto seja eliminado quando não houver mais referência. Essa estrutura então flexibiliza a regra do <em>borrow checker</em>, onde um objeto só deve ter um <em>owner</em>.
Na prática funcionará muito semelhante a outras linguagens com <em>GC</em>.</p>
<p>Na prática o Rc será o <em>owner</em> do objeto, então nunca acessaremos o objeto de forma <em>owned</em>.
Por isso é interessante o construtor do objeto já retornar o <code>Rc</code>.</p>
<p>Para utilizarmos o <code>Rc</code> cada estrutura que precisa ter uma referência dele, para isso devemos fazer clone do <code>Rc</code> (não do objeto).</p>
<p>Vamos ver como fica o exemplo acima utilizando <code>Rc</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::{path::PathBuf, rc::Rc};

#[derive(Debug, Clone)]
struct Node {
    path: PathBuf,
    parent: Option&lt;Rc&lt;Node&gt;&gt;,
}

impl Node {
    pub fn new(path: PathBuf) -&gt; Rc&lt;Node&gt; {
        let node = Self { path, parent: None };
        Rc::new(node)  // &lt;- Construtor criando e retornando o Rc
    }

    pub fn add_child(parent: &amp;Rc&lt;Node&gt;, path: PathBuf) -&gt; Self {
        let parent_rc = Rc::clone(parent); // &lt;- Clone apenas do Rc, não do Node
        Self {
            path,
            parent: Some(parent_rc),
        }
    }
}

fn main() {
    let node_parent = Node::new(PathBuf::from(&quot;C:\\&quot;));

    let node_child = Node::add_child(&amp;node_parent, PathBuf::from(&quot;TEMP&quot;));

    println!(&quot;Parent: {:?}&quot;, node_parent);
    println!(&quot;Child: {:?}&quot;, node_child);

    if let Some(parent) = node_child.parent {
        let n = &amp;*parent; // &lt;- Acessar objeto original
        println!(&quot;Parent: {:?}&quot;, n);
    }
}
</code></pre></pre>
<p>Observe que no construtor <code>new</code> retorna o <code>Rc</code> no método <code>add_child</code> é feito clone do <code>Rc</code>.
O custo desse clone é de apenas um ponteiro.</p>
<p>Existe outro <em>smart pointer</em> chamado <code>Arc</code>, que funciona como o <code>Rc</code>, porém o <code>Arc</code> permite se acessado por <em>threads</em> diferentes.</p>
<p>O <code>Rc</code> permite mais de uma referência do mesmo objeto, porém ele não permite mutabilidade.
Para permitir isso veremos outro <em>smart pointer</em> a seguir.</p>
<h2 id="refcellt-interior-mutability"><a class="header" href="#refcellt-interior-mutability"><code>RefCell&lt;T&gt;</code> (<em>Interior mutability</em>)</a></h2>
<p>O <code>RefCell</code> permite acessar um dados de forma mutável, mesmo que ele não esteja declaro como mutável.
Geralmente essa estrutura é utilizada em conjunto com o <em>Rc</em>, pois ele sozinho não faz <em>reference count</em>.</p>
<p>Para acessar a variável de forma mutável existe o método <code>borrow_mut</code>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::{cell::RefCell, path::PathBuf, rc::Rc};

#[derive(Debug, Clone)]
struct Node {
    path: PathBuf,
    parent: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

impl Node {
    pub fn new(path: PathBuf) -&gt; Rc&lt;RefCell&lt;Node&gt;&gt; {
        let node = Self { path, parent: None };
        let node_rc = RefCell::new(node);
        Rc::new(node_rc) // &lt;- Construtor criando e retornando o Rc
    }

    pub fn add_child(parent: &amp;Rc&lt;RefCell&lt;Node&gt;&gt;, path: PathBuf) -&gt; Self {
        let parent_rc = Rc::clone(parent); // &lt;- Clone apenas do Rc, não do Node
        Self {
            path,
            parent: Some(parent_rc),
        }
    }
}

fn main() {
    let node_parent = Node::new(PathBuf::from(&quot;C:\\&quot;));

    let node_child = Node::add_child(&amp;node_parent, PathBuf::from(&quot;TEMP&quot;));

    println!(&quot;Parent: {:?}&quot;, node_parent);
    println!(&quot;Child: {:?}&quot;, node_child);

    // Delimita escopo da variável p
    {
        let mut p = node_parent.borrow_mut(); // &lt;- Acessando a variável de forma mutável
        p.path = PathBuf::from(&quot;D:\\&quot;);
    }

    // Conferir se alterou parent
    println!(&quot;Parent: {:?}&quot;, node_parent);
    println!(&quot;Child: {:?}&quot;, node_child);
}
</code></pre></pre>
<p>O <code>borrow_mut</code> não permite que a variável seja acessada de forma mutável mais de uma vez simultaneamente. Ou seja, ele faz uma checagem em tempo de <em>runtime</em> para garantir que a mesma variável não está sendo acessada de forma mutável no mesmo escopo. Se isso ocorrerá uma <code>panic</code>.</p>
<h2 id="type-alias-para-tipos-complexos"><a class="header" href="#type-alias-para-tipos-complexos"><code>type</code> (alias para tipos complexos)</a></h2>
<p>Eventualmente pode começar a ficar extenso encadear várias estruturas, tal como <code>Rc&lt;RefCell&lt;Node&gt;&gt;</code>.</p>
<p>Para isso podemos declarar um <em>alias</em> através do <code>type</code>, por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type NodeRc = Rc&lt;RefCell&lt;Node&gt;&gt;

struct Node {
    path: PathBuf,
    parent: Option&lt;NodeRc&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Compreensivelmente não podemos acessar métodos estáticos do <em>type</em>, tal como <code>NodeRc::new</code>, isso não é possível.</p>
<h2 id="exercícios-4"><a class="header" href="#exercícios-4">Exercícios</a></h2>
<ul>
<li>Crie um programa para exemplo (<code>Box</code>, <code>Rc</code> e <code>RefCell</code>), cole os códigos fontes acima.</li>
<li>Aplique o <code>type</code> para simplificar a declaração dos objetos.</li>
<li>Cria um método <code>to_string()</code> no <code>Node</code>, para retornar a <em>string</em> do <em>path</em>. Se o <code>Node</code> possuir pai deve invocar o método do pai e concatenar com ele. Crie mais alguns níveis de <em>nodes</em>. Dica: para objet <em>string</em> do <code>PathBuf</code> pode usar <code>path.to_string_lossy()</code>.</li>
</ul>
<h1 id="threads"><a class="header" href="#threads"><em>Threads</em></a></h1>
<h2 id="introdução-2"><a class="header" href="#introdução-2">Introdução</a></h2>
<p>Nas linguagens em geral é responsabilidade do programador prever todos os problemas possíveis com concorrências de <em>threads</em>.</p>
<p>A forma como Rust trabalha com <em>threads</em> se diferencia das outras linguagens
pois ele tende a detectar problemas de concorrências em tempo de compilação.</p>
<p>Geralmente é utilizado o termo <em>fearless concurrency</em> (concorrência sem medo) para denominar essa
característica do Rust.</p>
<p>Rust permite trabalhar com <em>threads</em> através de chamadas a objetos e funções específicas, semelhante como Java.
Entretanto Rust também possui uma sintaxe <em>async</em> (criada mais recentemente), que funciona semelhante como no JavaScript, onde funções podem ser declaradas como assíncronas. Por enquanto não iremos abordar a sintaxe <em>async</em>.</p>
<p>Uma observação importante é que Rust não permite abortar (finalizar de forma abrupta) uma <em>thread</em>.
Isso por questão de boa prática de programação. O programador que deve implementar mecanismos para o encerramento da <em>thread</em>.</p>
<h2 id="criando-e-executando-threads"><a class="header" href="#criando-e-executando-threads">Criando e executando <em>threads</em></a></h2>
<p>Para trabalharmos com <em>threads</em> devemos usar o módulo <code>std::thread</code>.</p>
<p>A função <code>thread::spawn</code> permite criar e executar uma <em>thread</em>, onde podemos passar o código a ser executado
em <em>thread</em> separada através de <em>closure</em> (<em>call back</em>). Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    // Cria thread e a executa
    thread::spawn(|| { /* Código executado em thread separada */ });
}
</code></pre></pre>
<p>Para auxiliar nos nossos testes, podemos fazer uma pausa na execução do programa através do <code>sleep</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread::sleep(Duration::from_millis(500));
<span class="boring">}
</span></code></pre></pre>
<p>O exemplo abaixo executa um laço na <em>thread</em> principal e outro em <em>thread</em> separada:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<h2 id="join-aguardar-a-thread-concluir-ou-obter-retorno"><a class="header" href="#join-aguardar-a-thread-concluir-ou-obter-retorno"><code>join</code> (aguardar a <em>thread</em> concluir ou obter retorno)</a></h2>
<h3 id="aguardar-conclusão"><a class="header" href="#aguardar-conclusão">Aguardar conclusão</a></h3>
<p>Eventualmente queremos aguardar a <em>thread</em> concluir.
Para isso podemos usar o retorno da função <code>spawn</code>, que retorna um objeto <code>JoinHandle</code>.
Esse objeto possui o método <code>join</code>, que aguarda a conclusão da <em>thread</em>. Esse método retorna um <code>Result</code>,
que pode retornar erro caso ocorrer <code>panic</code> na <em>thread</em>. Exemplo que aguarda a conclusão:</p>
<pre><pre class="playground"><code class="language-rust">use std::{thread, time::Duration};

fn main() {
    let handle = thread::spawn(|| {
        println!(&quot;Dentro da thread...&quot;);
        thread::sleep(Duration::from_secs(3));
    });

    handle.join().unwrap();
    println!(&quot;Fim do programa&quot;);
}
</code></pre></pre>
<h3 id="obter-valor-gerado-pela-thread"><a class="header" href="#obter-valor-gerado-pela-thread">Obter valor gerado pela <em>thread</em></a></h3>
<p>Semelhante como em outras estruturas, o bloco da <em>thread</em> pode funcionar como expressão e tornar um valor.
Então nesse caso o <code>join</code> também pode retornar algum objeto gerado pela <em>thread</em>. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {

    let handle = thread::spawn(|| {
        5
    });

    let a = handle.join().unwrap();
    println!(&quot;a: {}&quot;, a);
}
</code></pre></pre>
<h2 id="capturar-variáveis-fora-da-thread"><a class="header" href="#capturar-variáveis-fora-da-thread">Capturar variáveis fora da <em>thread</em></a></h2>
<p>Caso a <em>thread</em> tente acessar uma variável fora da sua <em>thread</em>, é necessário usar o modificador <code>move</code> antes
do <em>closure</em>. Isso faz com que as varáveis acessadas sejam &quot;movidas&quot; para a outra <em>thread</em>, trocando o <em>ownership</em>.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {

    let a = 5;

    let handle = thread::spawn(move || {
        // Tentar acessar variável fora da thread
        println!(&quot;a: {}&quot;, a);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p>No exemplo acima, depois que o ocorrer o &quot;<em>move</em>&quot; da variável <code>a</code>, ainda podemos acessar essa variável dentro da <code>main</code>.
Isso funciona porque na prática o compilador faz um <code>copy</code> da variável. Mas ocorre somente para variáveis de tamanhos
conhecidos. Se alteramos a variável para ser uma <code>String</code>, por exemplo, então não podemos mais acessá-la na <code>main</code>.
Para contornar isso, uma das possibilidades é criar um <em>clone</em> da <code>String</code>.</p>
<h2 id="acessar-uma-mesma-variável-por-threads-distintas"><a class="header" href="#acessar-uma-mesma-variável-por-threads-distintas">Acessar uma mesma variável por <em>threads</em> distintas</a></h2>
<p>Eventualmente pode ser inconveniente fazer <em>clone</em> de variáveis entre <em>threads</em>, principalmente se possuir um tamanho significativo.
Nesse caso podemos usar o <em>smart pointer</em> <code>Arc</code>, que funciona semelhante ao <code>Rc</code>, porém faz <em>reference count</em> <em>thread safe</em>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::{sync::Arc, thread};

fn main() {
    let st = String::from(&quot;Conteúdo grande&quot;);
    let rc_main = Arc::new(st);
    let rc_spawned = rc_main.clone();

    let handle = thread::spawn(move || {
        println!(&quot;st spawned: {}&quot;, rc_spawned);
    });
    handle.join().unwrap();

    println!(&quot;st main: {}&quot;, rc_main);
}
</code></pre></pre>
<h2 id="mensagens-via-mpsc-multiple-producer-single-consumer"><a class="header" href="#mensagens-via-mpsc-multiple-producer-single-consumer">Mensagens via MPSC (Multiple Producer Single Consumer)</a></h2>
<p>Podemos realizar comunicação com a <em>thread</em> criada, onde é possível enviar e receber objetos - que podem funcionar como mensagens. Na prática podemos criar canais de comunicação <em>sender</em> (<em>tx</em>) e <em>receiver</em> (<em>rx</em>).</p>
<p>O par de canais é criado pela função <code>mpsc::channel()</code>, que retorna uma tupla para os tipos de objeto <code>Sender</code>
e <code>Receiver</code>. Esses objetos disponibilizam os métodos <code>send</code> e <code>recv</code>, respectivamente.
Observe que os tipos de parâmetro e retorno desses métodos serão o mesmo. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {

    // create send/receiver vars
    // to move data through channel
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {

        // value to be sent
        let a: i32 = 5;

        // the send() function will send
        // a value to the receiver (rx)
        tx.send(a).unwrap();
    });

    // catch the value with the recv()
    // function and store it in 'b'
    let b:i32 = rx.recv().unwrap();

    println!(&quot;Value a from extra thread: {}&quot;, b);
}
</code></pre></pre>
<h2 id="smart-pointer-mutex"><a class="header" href="#smart-pointer-mutex"><em>Smart pointer</em> <code>Mutex</code></a></h2>
<p>Para acessar um mesmo objeto entre diferentes <code>threads</code> deve usar <em>smart pointer</em> <code>Mutex</code>.
O <code>Mutex</code> possui o método <code>lock</code> permite criar um escopo onde somente uma <em>thread</em> irá acessar de cada vez.
Podemos associar ao comportamento da sintaxe <code>synchronized</code> do Java.
Este método <code>lock</code> retorna uma referência mutável do objeto que ele está armazenada.</p>
<p>O <code>Mutex</code> sozinho não realiza <em>reference count</em> para permitir múltiplas referências.
Para isso isso usaremos o <code>Arc</code>, que funciona semelhante ao <code>Rc</code>. Devemos colocar o <code>Mutex</code> dentro de um <code>Arc</code>,
e este por sua vez deve ser clonado por <code>Arc::clone</code> para ser repassado para as <em>threads</em>.</p>
<p>Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::{Mutex, Arc};

fn main() {

    // thread-safe and lockable
    let safe = Arc::new(Mutex::new(5));

    // more than one handle
    // store them in a vec
    // for convenience
    let mut handles = vec![];

    for i in 0..2 {
        // clone the transmitter
        let safe = Arc::clone(&amp;safe);
        // create the thread
        let handle = thread::spawn(move|| {

            // lock the value
            let mut a = safe.lock().unwrap();
            // mutate the value
            *a += 3;
        });

        // push the handle into the handles
        // vector so we can join them
        handles.push(handle);
    }

    // join the handles in the vector
    for i in handles {
        i.join().unwrap();
    }

    // lock the value when accessing it
    println!(&quot;a: {}&quot;, *safe.lock().unwrap());
}
</code></pre></pre>
<h2 id="paralelismo-com-iterators"><a class="header" href="#paralelismo-com-iterators">Paralelismo com <em>iterators</em></a></h2>
<p>Podemos percorrer <em>iterators</em> de forma paralelizada, semelhante ao <code>parallelStream</code> do Java.</p>
<p>Para isso devemos usar a biblioteca <a href="https://github.com/rayon-rs/rayon">Rayon</a>, que é mantida por
alguns dos principais desenvolvedores do compilador do Rust.</p>
<p>Inserir a dependência do <code>Cargo.toml</code>:</p>
<pre><code class="language-ini">[dependencies]
rayon = &quot;1.5&quot;
</code></pre>
<p>Exemplo de uso:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;

fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {
    input.par_iter() // &lt;-- just change that!
         .map(|&amp;i| i * i)
         .sum()
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Rayon</em> não serve apenas para criar <em>iterators</em> paralelos, ele também fornece uma solução completa de <em>thread pool</em>.</p>
<h2 id="referências"><a class="header" href="#referências">Referências</a></h2>
<p><a href="https://doc.rust-lang.org/book/ch16-01-threads.html">https://doc.rust-lang.org/book/ch16-01-threads.html</a></p>
<p><a href="https://www.koderhq.com/tutorial/rust/concurrency">https://www.koderhq.com/tutorial/rust/concurrency</a></p>
<h2 id="exercícios-5"><a class="header" href="#exercícios-5">Exercícios</a></h2>
<ul>
<li>Pratique a criação de <em>threads</em>, sem retorno e com retorno (utilizando <code>join</code>).</li>
<li>Pratique o acesso de variáveis externa pela <em>thread</em> (usar o <code>move ||</code>).</li>
<li>Com base no exemplo de MPSC:
<ul>
<li>Renomeie <code>tx</code> e <code>rx</code> para <code>to_main</code> e <code>from_th</code>.</li>
<li>Crie um novo par de <code>Sender</code> e <code>Receiver</code>, que
devem ter os nomes <code>to_th</code> e <code>from_th</code></li>
<li>Aplique eles de forma que faça o número 5 ser passado da <em>thread</em> principal para a <em>thread</em> secundária.</li>
<li>Dica: ao invés de <code>let a: i32 = 5;</code> deve ser algo como <code>let a: i32 = from_main.recv().unwrap();</code>.</li>
</ul>
</li>
</ul>
<h1 id="sintaxe-async"><a class="header" href="#sintaxe-async">Sintaxe async</a></h1>
<h2 id="introdução-3"><a class="header" href="#introdução-3">Introdução</a></h2>
<p>Rust permite uma sintaxe para declarar funções assíncronas, semelhante ao Javascript.
Essa sintaxe é um recurso relativamente novo no Rust, foi oficializado como estável em novembro de 2019.</p>
<blockquote>
<p>Algo que pode não parecer óbvio: execução paralela em <em>threads</em> e execução de funções assíncrona não significam a mesma coisa.</p>
</blockquote>
<ul>
<li>Execução em <em>threads</em> significa fazer várias coisas ao mesmo tempo.</li>
<li>Execução assíncrona significa que uma função pode &quot;pausar&quot; enquanto obtém o resultado, por sua vez outra função pode ser executada nesse meio tempo.</li>
</ul>
<p>É possível existir execução assíncrona usando uma única <em>thread</em>. É interessante imaginarmos execução assíncrona como <strong>escalonamento</strong>, onde uma mesma <em>thread</em> pode ser
compartilhada em funções distintas. Essas funções assíncronas também podemos chamar de <em><strong>tasks</strong></em>.</p>
<p>Documentação oficial sobre <a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">Programação Assíncrona em Rust</a>.</p>
<h3 id="runtimes-assíncronas"><a class="header" href="#runtimes-assíncronas"><em>Runtimes</em> assíncronas</a></h3>
<p>O gerenciar a execução das <em>tasks</em> pode variar de acordo de vários critérios, tal como quantidade de <em>cores</em> de CPU, tipo de acesso de I/O, etc. Além de que podem existir diferentes modelos de implementações. Visto esses fatos, Rust acaba não distribuindo por padrão a <em>runtime</em> de execução assíncrona, sendo necessário adicionar alguma biblioteca para isso.</p>
<p>A principais <em>runtimes</em> de execução assíncrona são:</p>
<ul>
<li><a href="https://rust-lang.github.io/futures-rs">Futures-rs</a>
A mais básica, criada pelos programadores do compilador.</li>
<li><a href="https://async.rs/">Async-std</a>
Além de disponibilizar <em>runtime</em> assíncrona, disponibiliza mapeamento de todas as rotinas
da <code>std</code> em versão assíncrona. Essa <em>runtime</em> também é a mais amigável.</li>
<li><a href="https://tokio.rs/">Tokio</a>
A <em>runtime</em> mais robusta que existe, entretanto é mais criteriosa e rígida na forma de trabalho.</li>
</ul>
<p>Nos nossos exercício iremos trabalhar com a <code>Futures-rs</code>, para isso devemos incluir a dependência no <code>Cargo.toml</code>:</p>
<pre><code class="language-ini">[dependencies]
futures = {version = &quot;0.3&quot;, features = [&quot;thread-pool&quot;]}
</code></pre>
<h2 id="sintaxe"><a class="header" href="#sintaxe">Sintaxe</a></h2>
<p>No geral a sintaxe <em>async</em> se assemelha muito a outras linguagens como Javascript, Dart, etc.</p>
<p>Em Rust podemos ter funções e blocos assíncronos. Para isso usamos a palavra reservada <code>async</code>. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn load_content() -&gt; String {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>O exemplo acima declara uma função assíncrona, que retorna <code>String</code>.
Entretanto a sintaxe <code>async</code> é um <em>sintaxe sugar</em> para indicar que
esta função retorna <code>Future&lt;String&gt;</code>.</p>
<p>Existem duas maneiras de iniciar a função: pelas funções &quot;<em>block</em>&quot; (síncrono) ou &quot;spawn&quot; (assíncrono).
Geralmente as <em>runtimes</em> assíncronas provem funções para isso.
Também existe a sintaxe <code>await</code> para aguardar a conclusão da função.</p>
<h3 id="chamada-síncrona-block_on"><a class="header" href="#chamada-síncrona-block_on">Chamada síncrona <em>block_on</em></a></h3>
<p>O exemplo abaixo chama uma função assíncrona <code>load_content</code> e aguarda o retorno:</p>
<pre><pre class="playground"><code class="language-rust">use futures::executor::block_on;

async fn load_content() -&gt; String {
    // ...
}

fn main() {
    let content = block_on(load_content());
    println!(&quot;{}&quot;, content);
}
</code></pre></pre>
<p>O mesmo programa poderia ser escrito assim:</p>
<pre><pre class="playground"><code class="language-rust">use futures::executor::block_on;

fn main() {
    let fut = load_content();
    let content = block_on(fut);
    println!(&quot;{}&quot;, content);
}
</code></pre></pre>
<p>No exemplo acima, a variável <code>fut</code> armazena um <code>Future</code>.
Observe que a execução da função só executou no <code>block_on</code>, retornando o conteúdo da função.
O <code>block_on</code> se assemelha ao <code>join</code> das <em>threads</em>.</p>
<h3 id="chamada-síncrona-await"><a class="header" href="#chamada-síncrona-await">Chamada síncrona <em>await</em></a></h3>
<p>Quando já estamos dentro de um bloco assíncrono, não necessitamos do <code>block_on</code>. Para isso podemos usar
a palavra reservada <code>await</code>, que deve ser usada semelhante a um método. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn initialize() {
    let content = load_content().await;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Observação: o escalonamento entre funções assíncrona ocorre no <code>await</code>.
Algumas documentações recomendam que a execução do programa não fique muito tempo sem alcançar algum <code>await</code>.</p>
<h3 id="chamada-assíncrona-spawn"><a class="header" href="#chamada-assíncrona-spawn">Chamada assíncrona <em>spawn</em></a></h3>
<p>Geralmente para fazer <em>spawn</em> de uma função assíncrona devemos fazer a partir de um gerenciador
<em>threads</em>. No caso da biblioteca <em>futures</em> usamos o <code>ThreadPool</code>, que possui o método <code>spawn_with_handle</code>.
Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">use futures::{
    executor::{block_on, ThreadPool},
    task::SpawnExt,
};

fn main() {
    let fut = load_content();

    let executor = ThreadPool::new().unwrap();

    let handle = pool.spawn_with_handle(fut).unwrap();
    // ...

    let content = block_on(handle);
    println!(&quot;{}&quot;, content);
}
</code></pre></pre>
<h3 id="bloco-async"><a class="header" href="#bloco-async">Bloco <code>async</code></a></h3>
<p>Além de funções assíncronas também podemos declarar bloco assíncrono pela palavra reservada <code>async</code>.
Esse bloco também retorna um <code>Future</code>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let fut = async {
        load_content().await
    };
    // ...
}
</code></pre></pre>
<p>Semelhante como em <em>closures</em> podemos usar sintaxe <em>move</em> para capturar variáveis, também podemos usar nos blocos <em>async</em>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let i = 0;
    let fut = async move {
        println!(&quot;{}&quot;, i);
    };
    // ...
}
</code></pre></pre>
<h2 id="efeitos-aplicação-e-limitações"><a class="header" href="#efeitos-aplicação-e-limitações">Efeitos, aplicação e limitações</a></h2>
<p>Antes de aplicar a sintaxe <code>async</code> numa aplicação Rust devemos estar cientes de alguns fatos.</p>
<h3 id="problem-of-effects"><a class="header" href="#problem-of-effects"><em>Problem of effects</em></a></h3>
<p>Na engenharia de <em>software</em> existe um conceito chamado <em>Effect System</em>, que fala sobre a característica
que um determinado tipo de efeito pode afetar uma região do <em>software</em>, sendo que o compilador pode verificar em tempo de compilação.</p>
<p>Um exemplo prático são as exceções checados no Java, onde efeito <em>throws</em> afeta uma região onde a exceção pode ser disparada.
Podemos ter um conjunto de funções &quot;empilhadas&quot;, sendo que se uma levanta exceção e as acima podem propagar exceção, até que algum momento será tratada e assim &quot;delimitará&quot; aquela região.</p>
<p>O caso das funções assíncronas ocorre algo semelhante. Uma função assíncrona pode chamar uma função síncrona, porém uma função assíncrona deve ser chamada a partir de um contexto assíncrono.</p>
<p>Isso causa um efeito que funções assíncronas tendem a se &quot;espalhar&quot;. Dependendo, isso pode aumentar a complexidade no desenvolvimento da aplicação ao misturar esses tipos de funções. Várias linguagens sofrem desse efeito. Alguns chamam esses tipos de funções (síncrona/assíncrona) de &quot;cores&quot;.</p>
<p>No caso do Rust é um pouco mais flexível, pois podemos chamar uma função assíncrona de dentro de um contexto síncrono.
Para isso geralmente as <em>run times</em> assíncronas do Rust possuem uma função chamada <code>block_on</code> - que aguarda a conclusão da função, semelhante ao <code>join</code> das <em>threads</em>.</p>
<p>Entretanto, só pode haver um <code>block_on</code> na pilha. O seguinte pseudo código causa erro de execução:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn a() {
    fn b();

    block_on(                // &lt;== block_on ok!
        async fn c() {

        }
    );

    block_on(                // &lt;== block_on ok! (primeiro na pilha)
        async fn d() {

            fn e();

            async fn f().await;

            fn g() {
              block_on(          // &lt;== problema!!! (segundo block_on)
                  async fn h();
              )
            }
        }

    )

}
<span class="boring">}
</span></code></pre></pre>
<p>A <em>runtime</em> <code>async-std</code> é a única que permite ter mais um <code>block_on</code> simultâneo na pilha.
O problema alegado é que nesse caso a <em>thread</em> não é escalonada corretamente para outras <em>tasks</em> (funções),
desperdiçando processamento.</p>
<p>Referências sobre <em>Problem of effects</em> e <em>Colored Functions</em>:</p>
<ul>
<li><a href="https://without.boats/blog/the-problem-of-effects">https://without.boats/blog/the-problem-of-effects</a></li>
<li><a href="https://en.wikipedia.org/wiki/Effect_system">https://en.wikipedia.org/wiki/Effect_system</a></li>
<li><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function">https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function</a></li>
<li><a href="https://www.hobofan.com/blog/2021-03-10-rust-async-colored">https://www.hobofan.com/blog/2021-03-10-rust-async-colored</a></li>
<li><a href="https://morestina.net/blog/1686/rust-async-is-colored">https://morestina.net/blog/1686/rust-async-is-colored</a></li>
</ul>
<h3 id="async-e-traits-interfaces"><a class="header" href="#async-e-traits-interfaces"><em>Async</em> e <em>traits</em> (interfaces)</a></h3>
<p>Nativamente não podemos criar funções <em>async</em> em <em>traits</em>.
Entretanto existe a biblioteca <a href="https://github.com/dtolnay/async-trait">async-trait</a> para isso.
A implementação nativa está sendo desenvolvida.</p>
<p>Mesmo a lib <code>async-trait</code> funcionando corretamente, eventualmente o <em>rust-analyzer</em> pode funcionar limitado dentro do bloco de código de uma <em>trait</em>.</p>
<h3 id="aplicação-de-prioridade-de-io-ou-cpu"><a class="header" href="#aplicação-de-prioridade-de-io-ou-cpu">Aplicação de prioridade de I/O ou CPU</a></h3>
<p>Uma das principais aplicações de execução assíncrona é para manipular I/O (arquivo, rede, banco de dados, etc),
pois esse tipo de acesso necessita de uma resposta do <em>hardware</em>,
sendo que durante esse período o processador está livre e outra tarefa pode ser executada.</p>
<p>Até podemos usar a sintaxe <em>async</em> para processamento de CPU, entretanto podemos encontrar opiniões e artigos que
questionam esse tipo de aplicação. Nesse caso recomendam usar a biblioteca <em>Rayon</em>.</p>
<h2 id="exercícios-6"><a class="header" href="#exercícios-6">Exercícios</a></h2>
<ul>
<li>Pratique a criação de algumas funções <em>async</em>.</li>
<li>Use <code>block_on</code>, <em>spawn</em> e <code>await</code>.</li>
</ul>
<h1 id="sqlx-acesso-bd"><a class="header" href="#sqlx-acesso-bd">SQLx (acesso BD)</a></h1>
<h2 id="introdução-4"><a class="header" href="#introdução-4">Introdução</a></h2>
<p>Existem várias bibliotecas para acessar banco de dados em Rust.
Entretanto não existe uma interface padrão para isso, tal como ODBC, OleDB ou JDBC.
Então ocorre que em geral as bibliotecas possuem suas próprias API que não compatíveis entre si.</p>
<p>No nosso treinamento iremos utilizar a <a href="https://github.com/launchbadge/sqlx">biblioteca <em>SQLx</em></a> que permite acessar PostGres, MySQL, MSSQL e SQLite.</p>
<p>Essa biblioteca não é um <em>ORM</em>, ou seja, ele não faz um mapeamento de objeto para modelo relacional do banco de dados.
Geralmente os <em>ORMs</em> disponibilizam uma API ou uma nova DSL para abstrair o SQL.
O principal motivo é forçar uma tipagem, de forma a validar a <em>query</em> em tempo de compilação, pois geralmente a <em>SQL</em> é definida em texto (<em>string</em>).
O problema disso é que essa API deve estudada, sem falar que muitas vezes fica mais verboso.</p>
<p>A grande vantagem do <em>SQLx</em> é que usa a <em>SQL</em> nativa do banco de dados e a <strong>valida em tempo de compilação</strong>.
Na prática a biblioteca valida a <em>string</em> diretamente conectando no banco de dados, graças a características que as macros são rotinas que podem ser executadas
em tempo de compilação. E a consulta também <strong>retorna objetos com os nomes e tipos
apropriados respeitando a SQL</strong>, ou seja, não tem como acessar um campo pelo nome ou tipo errado.</p>
<p>Isso tudo o torna extremamente poderoso, resultando em <strong>produtividade e qualidade</strong> (menos bugs).</p>
<h2 id="dependência-1"><a class="header" href="#dependência-1">Dependência</a></h2>
<p>Para usar a biblioteca devemos inserir a dependência no <code>Cargo.toml</code>:</p>
<pre><code class="language-ini">sqlx = {version = &quot;0.5.7&quot;, features = [&quot;sqlite&quot;, &quot;runtime-async-std-native-tls&quot;]}
</code></pre>
<p>No treinamento iremos praticar com SQLite, observe que acima inserimos uma <em>feature</em> <code>sqlite</code>.</p>
<p>A outra <em>feature</em> é a <code>runtime-async-std-native-tls</code>, que indica que iremos usar a runtime assíncrona <em>Async-std</em>.</p>
<h2 id="instalação"><a class="header" href="#instalação">Instalação</a></h2>
<p>O SQLx possui uma ferramenta para executar comandos pela linha de comando. Para instalar devemos executar:</p>
<pre><code class="language-terminal">cargo install sqlx-cli --no-default-features --features sqlite
</code></pre>
<p>Depois disso podemos executar os campos pelo programa <code>sqlx</code>.</p>
<h2 id="projeto-de-treinamento-todo"><a class="header" href="#projeto-de-treinamento-todo">Projeto de treinamento <em>TODO</em></a></h2>
<p>Para exercitarmos vamos clonar um projeto de teste já existente, <a href="http://gitlab.rechinfo.local/gitlab/rech/rust/treinamento/sqlx-todo">sqlx-todo</a>.
Esse programa serve como um cadastro simples de <em>To do list</em>.</p>
<p>Vamos clonar o projeto, entre no diretório <code>c:\fontes\rust</code> e digite :</p>
<pre><code class="language-terminal">git clone http://gitlab.rechinfo.local/gitlab/rech/rust/treinamento/sqlx-todo.git
</code></pre>
<p>Será criado o diretório <code>sqlx-todo</code>. Abra esse diretório no <em>VSCode</em>.</p>
<p>Uma novidade é a função <code>main</code>, que nosso projeto já uma função assíncrona:</p>
<pre><pre class="playground"><code class="language-rust">#[paw::main]
#[async_std::main]
async fn main(args: Args) -&gt; Result&lt;()&gt; {
    // ...
}
</code></pre></pre>
<h2 id="arquivo-env"><a class="header" href="#arquivo-env">Arquivo <code>.env</code></a></h2>
<p>Uma das principais formas para parametrizar os dados de conexão é através de variável de ambiente.
Entretanto as vezes pode ser útil também ler através de um arquivo.
Para facilitar isso existe uma técnica utilizada por diversas ferramentas (inclusive o <em>SQLx</em>), que tenta carregar variáveis de ambiente através de um arquivo <code>.env</code> contido no diretório corrente ou anterior.</p>
<p>Cada linguagem possui suas bibliotecas para ler esse arquivo <code>.env</code> e definir as variáveis de ambiente.</p>
<p>No caso do Rust usaremos a biblioteca <code>dotenv</code>.</p>
<h2 id="criar-o-banco-de-dados"><a class="header" href="#criar-o-banco-de-dados">Criar o banco de dados</a></h2>
<p>Criar banco de dados a partir da definição do arquivo <code>.env</code> devemos executar:</p>
<pre><code class="language-terminal">sqlx db create
</code></pre>
<p>A execução desse comando cria o arquivo <code>todos.db</code> na raiz do projeto.</p>
<h2 id="migration"><a class="header" href="#migration"><em>Migration</em></a></h2>
<p>O termo <em>migration</em> (migração) geralmente é utilizado por bibliotecas de acesso a banco de dados, como o procedimento
para manter o banco de dados da aplicação com a estrutura esperada, registrando e executando as operações necessários.</p>
<p>Cada mudança no banco deve ser registrado num arquivo de migração, que contém a SQL para fazer a alteração (<code>CREATE TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>, etc).</p>
<p>O <em>SQLx</em> contém um controle para saber quais arquivos de migração devem ser executados, executando as adaptações necessárias.
Os arquivos de migração ficam localizados no diretório <code>migrations</code> na raiz do projeto.</p>
<p>Essas migrações podem ser executadas tanto no ambiente de produção quanto de desenvolvimento. Para fazer as migrações devemos executar o comando:</p>
<pre><code>sqlx migrate run
</code></pre>
<h2 id="execução-do-programa-de-teste-todo"><a class="header" href="#execução-do-programa-de-teste-todo">Execução do programa de teste <em>TODO</em></a></h2>
<p>Listar os <em>TODOs</em>:</p>
<pre><code class="language-terminal">cargo run --
</code></pre>
<p>Inserir novo <em>TODO</em>:</p>
<pre><code class="language-terminal">cargo run -- add [descrição]
</code></pre>
<p>Marcar <em>TODO</em> como realizado:</p>
<pre><code class="language-terminal">cargo run -- done [id]
</code></pre>
<h2 id="sqlx"><a class="header" href="#sqlx"><em>SQLx</em></a></h2>
<p>O funcionamento do <em>SQLx</em> é bem simples. A primeira coisa que devemos
saber é que uma biblioteca assíncrona, ou seja, as funções devem ser executada
em contexto <em>async</em>.</p>
<p>Para conectar no banco existe o método <code>SqlitePool::connect</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pool = SqlitePool::connect(&amp;env::var(&quot;DATABASE_URL&quot;)?).await?;
<span class="boring">}
</span></code></pre></pre>
<p>Esse objeto pode ser clonado várias vezes sem nenhum problema, ele gerencia um <em>pool</em> de conexão de forma transparente, ou seja, não será feita um conexão para instância
clonada a não ser que seja realmente necessário.</p>
<p>Para executar comando <em>SQL</em> (<em>SELECT, INSERT, UPDATE</em>, etc) devemos usar a macro <code>query!</code>, tal como:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let recs = query!(r#&quot;SELECT id, description, done FROM todos ORDER BY id&quot;#)
    .fetch_all(pool)
    .await?;
<span class="boring">}
</span></code></pre></pre>
<p>Observe que o <code>pool</code> é passado para o método <code>fetch_all</code>. O retorno <code>recs</code> será
um objeto criado dinamicamente em tempo de compilação, de acordo com o tipo dos campos selecionados.</p>
<h2 id="exercícios-7"><a class="header" href="#exercícios-7">Exercícios</a></h2>
<ul>
<li>No programa de exemplo ele tem uma funcionalidade para listar os <em>TODOs</em>. Crie uma parametrização na <em>command line</em> para permitir escolher a ordem (id, descrição, concluído, etc).</li>
<li>Nessa mesma funcionalidade de listar, permita parametrizar se deve exibir os já concluídos ou não.</li>
</ul>
<h1 id="traits-interfaces"><a class="header" href="#traits-interfaces"><em>Traits</em> (interfaces)</a></h1>
<h2 id="introdução-5"><a class="header" href="#introdução-5">Introdução</a></h2>
<p>Em Rust o equivalente a interface seria a <code>trait</code>. Não se chama interface pois a <em>trait</em> tem um comportamento mais estendido, onde permite criar métodos que podem ser reaproveitado entre as implementações.
Algumas linguagens chamam esse conceito de <em>mixin</em>.</p>
<p>Muitos dos comportamentos da linguagem é dito pelo uso de <em>traits</em>. Por exemplo, operações lógicas e aritméticas implementam <em>traits</em>. Isso permite que nós possamos utilizar esse tipo de operação nos nossos próprios objetos.</p>
<p>Também podemos implementar <em>traits</em> nossas para objetos já existentes, inclusive objetos nativos e de terceiros.
Isso é extremamente poderoso principalmente para construção de APIs, onde podemos generalizar e tornar vários tipos compatíveis com nossas rotinas.</p>
<h2 id="declaração"><a class="header" href="#declaração">Declaração</a></h2>
<p>Para declarar uma <code>trait</code> devemos fazer semelhante como fazemos com <code>struct</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait MyTrait {
    fn name(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>Para implementação devemos ter um bloco do tipo <code>impl Trait for Struct</code>.
Esse bloco fica fora do <code>impl</code> da implementação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyStructA {
    name: String,
}

impl MyStructA {
    pub fn new(name: String) -&gt; Self {
        Self {
            name,
        }
    }
}

// Implementação da trait para este struct
impl MyTrait for MyStructA {
    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe que essa distinção é bem interessante pois facilmente sabemos quais métodos estão
sendo implementados por cada <em>trait</em>. No Java por exemplo, apenas aparece um <code>@override</code>.</p>
<p>Podemos inclusive implementar em um arquivo fonte diferente de onde está declarado.
Por exemplo, posso implementar <code>MyTrait</code> no <em>struct</em> <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implementação da trait para String
impl MyTrait for String {
    fn name(&amp;self) -&gt; String {
        &quot;string name&quot;.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="traitsinterfaces-e-suas-implicações-no-uso-de-memória-e-performance"><a class="header" href="#traitsinterfaces-e-suas-implicações-no-uso-de-memória-e-performance"><em>Traits/interfaces</em> e suas implicações no uso de memória e performance</a></h2>
<p>Rust possui algumas sintaxes para permitir um melhor uso de memória e obter também um melhor desempenho. A seguir vamos abordar alguns desses
aspectos referente ao uso com <em>traits</em>.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Um fato que ocorre em todas linguagens que permitem polimorfismo, ao executar um método de interface (assim como <em>traits</em>),
para cada invocação é necessário o programa consultar uma tabela chamada <em>vtable</em>.
Essa tabela virtual possui a associação do método da interface com o endereço real do método de cada implementação.</p>
<p>Isso significa que invocar métodos de uma interface é mais lento que invocar um método de um tipo concreto.</p>
<h4 id="dynamic-dispatch-e-static-dispatch"><a class="header" href="#dynamic-dispatch-e-static-dispatch"><em>Dynamic dispatch e static dispatch</em></a></h4>
<p>Tendo preocupação com os aspectos acima, Rust permite trabalhar com <em>traits</em>
de duas formas: <em>dynamic dispatch</em> e <em>static dispatch</em>.</p>
<ul>
<li>
<p><em><strong>Dynamic dispatch</strong></em> é a forma que a maioria das linguagens trabalha. Nesse formato toda invocação de métodos consulta a tabela <em>vtable</em>.
Também não é possivel alocar memória na <em>stack</em>.</p>
</li>
<li>
<p><em><strong>Static dispatch</strong></em> por sua vez não necessita da tabela <em>vtable</em> e
é possível alocar o objeto na <em>stack</em>.
Isso é possível pelo fato que na prática o compilador cria uma &quot;versão&quot;
da função para cada implementação. Então durante a execução da função
o compilador sabe exatamente qual objeto está acessado. Isso logicamente
aumenta o código gerado porém há ganho de performance.</p>
</li>
</ul>
<p>Para diferenciar entre os dois tipos de <em>dispatch</em> é utilizada as palavras reservadas <code>dyn</code> (<em>dynamic</em>) e <code>impl</code> (<em>static</em>).
O <code>impl</code> somente pode ser declarado em parâmetros e retorno de funções,
então na prática o <code>dyn</code> será mais utilizado.</p>
<h3 id="alocação-de-memória"><a class="header" href="#alocação-de-memória">Alocação de memória</a></h3>
<p>Como sabemos Rust possui uma preocupação sobre alocação de memória,
de forma que tende usar a memória <em>stack</em> para tipos de tamanhos conhecidos.</p>
<p>Cada <em>trait</em> pode generalizar vários tipos de estruturas,
então o seu tamanho pode ser desconhecido.
Esse fato pode fazer com o compilador não aloque a memória na <em>stack</em>,
pois não tem como antever a memória necessária em tempo de compilação.</p>
<h4 id="uso-de-box"><a class="header" href="#uso-de-box">Uso de Box</a></h4>
<p>Pelo fato da implementação dinâmica <code>dyn</code> não poder representar
uma área na <em>stack</em>, obrigatoriamente alocará na <em>heap</em>.
Para indicar uma área alocada na <em>heap</em> é utilizado o tipo de objeto
<code>Box&lt;T&gt;</code>.</p>
<p>Será muito comum utilizarmos esse tipo de objeto para armazenar
uma <em>trait</em>. Nesse caso temos que informar o <code>dyn</code>.  Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instance: Box&lt;dyn Trait&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>No caso de referência podemos declarar sem o <code>Box</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let instance: &amp;dyn Trait;
<span class="boring">}
</span></code></pre></pre>
<h2 id="exemplo-prático"><a class="header" href="#exemplo-prático">Exemplo prático</a></h2>
<p>Um bom exemplo de uso de interface/<em>trait</em> é tornar a aplicação
desacoplada da implementação que obtém um valor a partir de arquivo
de configuração. Vamos imaginar uma rotina que obtém o <em>id</em> do
cliente em execução e o caminho do banco de dados. Em produção
a aplicação pode usar a implementação que lê esses dados de arquivo ini, entretanto para testes unitários podemos mocar esses dados
para um ambiente de desenvolvimento.</p>
<p>Nesse exemplo vamos declarar a estrutura de configuração:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Config {
    customer_id: u32,
    data_base_uri: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>Essa estrutura deve ser obtida por um <em>provider</em>, que pode ter diversas
implementações.</p>
<p>A trait do provider será assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ConfigProvider {
    fn load(&amp;self) -&gt; Config;
}
<span class="boring">}
</span></code></pre></pre>
<p>Esta <em>trait</em> declara o método <code>load</code>. Observe que ele dever ter
o parâmetro <code>&amp;self</code>, que indica método dinâmico.</p>
<p>Agora vamos declarar a implementação:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FileConfigProvider {
    config_file: PathBuf,
}

impl FileConfigProvider {
    fn new(config_file: PathBuf) -&gt; Self {
        Self { config_file }
    }
}

impl ConfigProvider for FileConfigProvider {
    fn load(&amp;self) -&gt; Config {
        //TODO: Create Config from ini file here...
        Config {
            customer_id: 4070,
            data_base_uri: String::from(&quot;localhost:5020&quot;),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe a linha <code>impl ConfigProvider for FileConfigProvider</code>,
é aqui que declaramos a implementação da interface.</p>
<p>Agora vamos ver como armazenamos a variável que recebe a <code>trait</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let config_file = PathBuf::from(&quot;APP.ini&quot;);

    let config_provider: Box&lt;dyn ConfigProvider&gt; = Box::new(FileConfigProvider::new(config_file));

    let config = config_provider.load();
    println!(
        &quot;Customer id: {} data base URI: {}&quot;,
        config.customer_id, config.data_base_uri
    );
}
</code></pre></pre>
<p>Observe que a variável <code>config_provider</code> é <em>owned</em>, ou seja,
é dona do objeto. Por isso nesse caso é obrigado a usarmos o <code>Box</code>.
Caso fosse armazenar a referência então pode usar o <code>&amp;dyn ConfigProvider</code>. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let config_file = PathBuf::from(&quot;APP.ini&quot;);

    let config_provider: &amp;dyn ConfigProvider = &amp;FileConfigProvider::new(config_file);

    let config = config_provider.load();
    println!(
        &quot;Customer id: {} data base URI: {}&quot;,
        config.customer_id, config.data_base_uri
    );
</code></pre></pre>
<h2 id="definir-parâmetro"><a class="header" href="#definir-parâmetro">Definir parâmetro</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn show_config(config_provider: &amp;dyn ConfigProvider) {
    let config = config_provider.load();
    println!(
        &quot;Customer id: {} data base URI: {}&quot;,
        config.customer_id, config.data_base_uri
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Para passarmos um <code>Box&lt;dyn Trait&gt;</code> para <code>&amp;dyn Trait</code> temos que tirar o Box com <code>*</code> (de-referência) e depois acessar por <code>&amp;</code> referência. Por exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>show_config(&amp;*config_provider);
<span class="boring">}
</span></code></pre></pre>
<p>Para passar uma <em>trait</em> via referência é um pouco mais verboso:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn show_config_impl(config_provider: &amp;(impl ConfigProvider + ?Sized)) {
    let config = config_provider.load();
    println!(
        &quot;Customer id: {} data base URI: {}&quot;,
        config.customer_id, config.data_base_uri
    );
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="definir-retorno"><a class="header" href="#definir-retorno">Definir retorno</a></h2>
<p>Podemos definir retorno de uma função com <code>impl T</code> ou <code>Box&lt;dyn T&gt;</code>.</p>
<p>Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_config_provider_impl() -&gt; impl ConfigProvider {
    FileConfigProvider::new(PathBuf::from(&quot;APP.ini&quot;))
}
<span class="boring">}
</span></code></pre></pre>
<p>Para uma função que retorna <code>impl</code> a função deve retornar somente um tipo de implementação.
Caso essa função tentar retornar mais de um tipo de implementação ocorrerá um erro de compilação.
Para contornar isso deve ser utilizado o retorno dom <code>dyn</code>. Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_config_provider_dyn() -&gt; Box&lt;dyn ConfigProvider&gt; {
    Box::new(FileConfigProvider::new(PathBuf::from(&quot;APP.ini&quot;)))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="declarar-field-como-trait"><a class="header" href="#declarar-field-como-trait">Declarar <em>field</em> como <em>trait</em></a></h2>
<p>Para declarar campo contendo uma trait em geral usamos <code>Box&lt;T&gt;</code>.
O exemplo mostra como receber uma <em>trait</em> por <code>dyn</code> e <code>impl</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StructTraitBoxed {
    data_set: Box&lt;dyn DataSet&gt;,
}

impl StructTraitBoxed {
    pub fn from_impl(data_set: impl DataSet + 'static) -&gt; Self {
        Self {
            data_set: Box::new(data_set),
        }
    }

    pub fn from_box(data_set: Box&lt;dyn DataSet&gt;) -&gt; Self {
        Self { data_set }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Observe que usamos <code>impl DataSet + 'static</code>, que é uma restrição técnica para garantir que
a <em>trait</em> não conterá nenhum referência externa com tempo de vida curta.</p>
<p>Outra possibilidade é usar <em>generic</em> com <em>bounds</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StructTraitGeneric&lt;T: DataSet&gt; {
    data_set: T,
}

impl&lt;T: DataSet&gt; StructTraitGeneric&lt;T&gt; {
    pub fn from_impl(data_set: T) -&gt; Self {
        Self { data_set }
    }

    pub fn from_box(data_set: Box&lt;T&gt;) -&gt; Self {
        Self {
            data_set: *data_set,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Esse tipo acima deve ser evitado pois ele pode causar o efeito que a declaração
da <em>generic</em> acaba se espalhando.</p>
<h2 id="pattern-para-simular-sobrecarga-de-parâmetros"><a class="header" href="#pattern-para-simular-sobrecarga-de-parâmetros"><em>Pattern</em> para simular sobrecarga de parâmetros</a></h2>
<p>Apesar que Rust nativamente não permite sobrecarga de parâmetros,
podemos simular esse comportamento através do uso de <em>traits</em>.
Isso é possível graças a possibilidade de implementarmos <em>traits</em>
para qualquer tipo do Rust, inclusive tipo nativos.
Exemplo:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FieldValue {
    value: String,
}

impl FieldValue {
    pub fn new(value: String) -&gt; Self {
        Self { value }
    }
}

trait IntoFieldValue {
    fn to_value(self) -&gt; FieldValue;
}

impl IntoFieldValue for String {
    fn to_value(self) -&gt; FieldValue {
        FieldValue::new(self)
    }
}

impl IntoFieldValue for i64 {
    fn to_value(self) -&gt; FieldValue {
        FieldValue::new(self.to_string())
    }
}

fn create_field(into_field_value: impl IntoFieldValue) -&gt; FieldValue {
    into_field_value.to_value()
}

#[test]
fn create_field_test() {
    create_field(String::from(&quot;10&quot;));
    create_field(10i64);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="exercício"><a class="header" href="#exercício">Exercício</a></h2>
<p>No nosso último exercício de <em>TO-DO List</em> temos funções estáticas para ler e gravar
dados do <em>SQLite</em>. Esse seria um bom caso para aplicarmos <em>traits</em>, pois no futuro
podermos ter implementação para ler os nossos <em>TODOs</em> de diferente fonte de dados.</p>
<p>Como temos funções <em>async</em> a nossa trait precisará da lib <code>async-trait</code>. Para isso
precisaremos incluir no <code>Cargo.toml</code>:</p>
<pre><code class="language-ini">[dependencies]
async-trait = &quot;0.1&quot;
</code></pre>
<p>Também será necessário incluir o atributo <code>#[async_trait]</code> em dois pontos:
na declaração e implementação da <em>trait</em>.</p>
<p>A declaração da <em>trait</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait TodoRepository {
    async fn add_todo(&amp;self, description: String) -&gt; Result&lt;i64&gt;;
    async fn complete_todo(&amp;self, id: i64) -&gt; Result&lt;bool&gt;;
    async fn list_todos(&amp;self) -&gt; Result&lt;()&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>A declaração da implementação <em>SQLite</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TodoSqliteRepository {
    pool: SqlitePool,
}

impl TodoSqliteRepository {
    pub fn new(pool: SqlitePool) -&gt; Self {
        Self { pool }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementando a <em>trait</em> na implementação <em>SQLite</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl TodoRepository for TodoSqliteRepository {
    async fn add_todo(&amp;self, description: String) -&gt; Result&lt;i64&gt; {
        add_todo(&amp;self.pool, description).await
    }

    async fn complete_todo(&amp;self, id: i64) -&gt; Result&lt;bool&gt; {
        complete_todo(&amp;self.pool, id).await
    }

    async fn list_todos(&amp;self) -&gt; Result&lt;()&gt; {
        list_todos(&amp;self.pool).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Para usar a <em>trait</em> deve fazer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sqlite_repository: &amp;dyn TodoRepository = &amp;TodoSqliteRepository::new(pool);
<span class="boring">}
</span></code></pre></pre>
<p>Faça os ajustes necessários para chamar os métodos da <em>trait</em> ao invés dos métodos estáticos.</p>
<h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<h2 id="introdução-6"><a class="header" href="#introdução-6">Introdução</a></h2>
<p>Em geral as palavras <em>Lambda</em> e <em>Closure</em> são citadas para explicar dois conceitos que possuem a mesma relação. Dependendo da linguagem pode se chamar por um ou outro.</p>
<p><em>Closure</em> é o recurso da linguagem Rust que um trecho de código pode ser executado por &quot;<em>callback</em>&quot;, onde alguma outra rotina chama essa execução, permitindo passar parâmetro e obter seu resultado se necessário. Essa rotina a ser chamada é declarada como um função anônima (<em>Lambda</em>), podendo capturar variáveis do ambiente em que está declarada (<em>Closure</em>).</p>
<p>Então para esclarecer a diferença entre <em>Lambda</em> e <em>Closure</em>:</p>
<blockquote>
<ul>
<li><em>Lambda is anonymous function (method)</em></li>
<li><em>Closure is function which closes over (capture) variables from its enclosing scope (e.g. non-local variables)</em></li>
</ul>
</blockquote>
<h2 id="comparação-com-outras-linguagens"><a class="header" href="#comparação-com-outras-linguagens">Comparação com outras linguagens</a></h2>
<p>Java originalmente não permitia <em>Lambda</em>, mas em uma determinada versão foi implementado.
Entretanto para não criar uma nova sintaxe eles reaproveitaram a declaração de interfaces, onde
definiram a &quot;interface funcional&quot;, que poderia ter um único método.
E com base nisso criaram um <em>sintaxe sugar</em> que usa a assinatura do único método definido na interface.
Exemplo:</p>
<pre><code class="language-java">interface StringFunction {
  String run(String str);
}

StringFunction exclaim = (s) -&gt; s + &quot;!&quot;;

public class Main {

  public static void printFormatted(String str, StringFunction format) {
    String result = format.run(str);
    System.out.println(result);
  }

  public static void main(String[] args) {
    StringFunction exclaim = (s) -&gt; s + &quot;!&quot;;
    printFormatted(&quot;Hello&quot;, exclaim);
  }

}
</code></pre>
<p>Delphi por sua ver permite declarar um &quot;tipo funcional&quot; com a assinatura:</p>
<pre><code class="language-pascal">TStringFunction = reference to function( AStr: String ): String;

procedure PrintFormatted( AStr: String; AStringFunction: TStringFunction );
begin
  println(AStringFunction(AStr));
end;

begin
  PrintFormatted( function(S: String) begin
      Result := s + &quot;!&quot;;
    end
  );
end.

</code></pre>
<p>Rust se difere dessas linguagens pois permite declarar a assinatura do método
na própria declaração, sem precisar de uma declaração &quot;auxiliar&quot;. Por isso em
Rust é desnecessário interfaces funcionais como no Java,</p>
<h2 id="estrutura-de-diretórios-do-rust"><a class="header" href="#estrutura-de-diretórios-do-rust">Estrutura de diretórios do Rust</a></h2>
<p>Em Rust, chamamos de itens as declarações de um fonte: funções, <em>structs</em>, <em>enums</em>, <em>traits</em> (interfaces), etc.
Podemos agrupar os itens em <em>modules</em> (módulos), que lembra o conceito de pacotes de outras linguagens.
Porém é um pouco diferente do Java, que, por exemplo, cada pacote é obrigatoriamente um diretório.</p>
<blockquote>
<p>Em Rust é possível declarar mais de um módulo num mesmo fonte, ou o contrário, diferentes fontes compor um único módulo.
<strong>Porém para simplificar nós iremos trabalhar semelhante como no Java, onde cada módulo será um diretório.</strong></p>
</blockquote>
<h2 id="separar-itens-em-diferente-fonte"><a class="header" href="#separar-itens-em-diferente-fonte">Separar itens em diferente fonte</a></h2>
<p>O arquivo <code>main.rs</code>, além de conter a função de entrada <code>main</code>, também serve para declarar outros <em>modules</em> que estarão contido dentro do nível <code>src</code>.
Vamos supor que queremos isolar a declaração de objetos <code>Application</code> e <code>Config</code> em fontes separados.
E criar os arquivos <code>application.rs</code>, <code>config.rs</code> dentro do diretório <code>src</code>, com os respectivos fontes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Application {
    pub version: String,
}

pub struct Config {
    pub debug: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>A estrutura de diretórios ficará assim:</p>
<pre><code>src/
    application.rs *
    config.rs *
    main.src

* arquivos novos
</code></pre>
<p>Só o fato de haver arquivos <code>.rs</code> no <code>src</code> não os tornam visíveis, é necessário declará-los como módulos.
Para isso devemos declaras as seguintes linhas no <strong>topo</strong> do <code>main.rs</code> através das palavras <code>pub mod</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub mod application;
pub mod config;

fn main() {

}
</code></pre></pre>
<p>Apesar de declarar os módulos no <code>main.rs</code>, para acessar esses objetos devemos fazer o <em>import</em> abaixo dos <em>mods</em>. Ficará assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod application;
pub mod config;

use config::Config;
use application::Application;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Observe que existe um <code>::</code> para delimitar o pacote e a classe.
Diferente de Java, num fonte podemos declarar várias classes públicas.
Então devemos imaginar <code>config::Config;</code> funcionando como: <code>&lt;config.rs&gt;::Struct Config;</code></p>
</blockquote>
<p>Pronto, agora podemos usar as classes na função <code>main</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub mod application;
pub mod config;

use config::Config;
use application::Application;

fn main() {
    let application = Application {
        version: &quot;20.20a&quot;.to_string(),
    };
}
</code></pre></pre>
<h2 id="visibilidade-de-itens"><a class="header" href="#visibilidade-de-itens">Visibilidade de itens</a></h2>
<p>Perceba a palavra <code>pub</code> que utilizamos no exemplo acima na declaração do <code>struct</code> e nos campos. O <code>pub</code> torna visível para itens de outros <em>modules</em>.
Por padrão os itens são visível somente para outros itens do mesmo <code>module</code>. Podemos usar o <code>pub</code> em todos itens (funções, enum, etc).
O <code>mod</code> também permite visibilidade &quot;privada&quot; (sem o pub), nesse caso estará visível para o seu nível e níveis filhos.
Por padrão vamos declarar o módulo sempre com <code>pub</code>.</p>
<h2 id="criando-subdiretórios"><a class="header" href="#criando-subdiretórios">Criando subdiretórios</a></h2>
<p>Os pacotes <code>application</code> e <code>config</code> então no mesmo nível (diretório) de <code>main</code>.</p>
<p>Agora vamos criar um novo diretório <code>model</code>. A estrutura ficará assim:</p>
<pre><code>src/
    model/ *
    application.rs
    config.rs
    main.src

* diretório novo
</code></pre>
<p>E semelhante como fizemos antes com os arquivos novo, no <code>main.rs</code> temos que declarar o diretório <code>entity</code> com <code>mod</code>.
Ficará assim:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod model; // &lt;- diretório que estamos declarando
pub mod application;
pub mod config;
...
<span class="boring">}
</span></code></pre></pre>
<p>Então agora vamos criar os arquivos <code>user.rs</code>, <code>group.rs</code> e <code>rule.rs</code> dentro do diretório <code>model</code>.</p>
<p>Em cada fonte vamos declarar seus <em>structs</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct User {
    pub id: u32,
    pub name: String,
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Group {
    pub id: u32,
    pub name: String,
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Rule {
    pub id: u32,
    pub name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>A estrutura ficará assim:</p>
<pre><code>src/
    model/
        user.rs *
        group.rs *
        rule.rs *
    application.rs
    config.rs
    main.src

* arquivos novos
</code></pre>
<p>Semelhante como no os fontes <code>application.rs</code> e <code>config.rs</code> devemos declarar o módulo com <code>mod</code>.
Mas nesse caso os fontes não então na raiz <code>src</code> e sim dentro do <code>model</code>.
Nesse caso o diretório deve conter um arquivo chamado <code>mod.rs</code>. A estrutura ficará assim:</p>
<pre><code>src/
    model/
        group.rs
        mod.rs *
        rule.rs
        user.rs
    application.rs
    config.rs
    main.src

* arquivo novo
</code></pre>
<p>E no arquivo <code>mod.rs</code> deve conter a declaração de cada fonte deste subdiretório:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod user;
pub mod group;
pub mod rule;
<span class="boring">}
</span></code></pre></pre>
<p>Se fossemos criar um diretório <code>model/commons/</code> então <code>commons</code> teria que ser declarado dentro do <code>mod.rs</code> do <code>model</code>,
e assim recursivamente.</p>
<h2 id="recapitulando-declaração-de-módulos"><a class="header" href="#recapitulando-declaração-de-módulos">Recapitulando declaração de módulos</a></h2>
<ul>
<li>Arquivos fontes e diretórios devem ser declarados com <code>pub mod</code>.</li>
<li>Esses <code>pub mod</code> devem estar no <code>main.rs</code> (quando arquivos/diretórios na raiz <code>src</code>) ou no arquivo <code>mod.rs</code> contido no diretório.</li>
<li>Cada sub nível de diretório terá o seu próprio <code>mod.rs</code>.</li>
<li>Se for criar um diretório</li>
</ul>
<blockquote>
<p>Pode parece ser trabalhoso, mas <em>language server</em> tem um facilitador para inserir o <code>pub mod</code> no arquivo necessário.
No topo do fonte novo aparecerá a &quot;lámpada verde&quot; para fazer essa alteração para nós.
Geralmente o único trabalho que temos é criar o arquivo <code>mod.rs</code> dentro de um diretório novo.</p>
</blockquote>
<h2 id="declarando-imports-com-via-relativa-ou-absoluta"><a class="header" href="#declarando-imports-com-via-relativa-ou-absoluta">Declarando <em>imports</em> com &quot;via relativa&quot; ou absoluta</a></h2>
<p>É possível acessar os módulos com caminho de forma absoluta ou relativa.</p>
<ul>
<li><code>crate</code> Para acessar a raiz, tal como <code>/</code></li>
<li><code>super</code> Para acessar o nível anterior, tal como <code>..</code></li>
<li><code>self</code> Para acessar a partir do nível atual, tal como <code>.</code></li>
</ul>
<p>Exemplos:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::application::Application;
use super::application::Application;
use self::application::Application;
<span class="boring">}
</span></code></pre></pre>
<h2 id="clonar-structs"><a class="header" href="#clonar-structs">Clonar structs</a></h2>
<h3 id="atribuição-de-um-struct-para-a-outro"><a class="header" href="#atribuição-de-um-struct-para-a-outro">Atribuição de um <code>struct</code> para a outro</a></h3>
<p>Ao tentarmos fazer uma atribuição teremos um erro de compilação devido ao controle de <em>Ownership</em>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    id: u32,
</span><span class="boring">    name: String,
</span><span class="boring">}
</span>fn main() {
    let user_a = User {
        id: 19,
        name: String::from(&quot;Vanius&quot;),
    };
    let user_b = user_a;
    println!(&quot;User a: {} {}&quot;, user_a.id, user_a.name); // &lt;= Error!
    println!(&quot;User b: {} {}&quot;, user_b.id, user_b.name);
}
</code></pre></pre>
<p>Como vimos no capítulo sobre <em>Ownership</em>, a linha <code>let user_b = user_a;</code> causa o <em>move</em> do valor de <code>User</code>.</p>
<p>Também vimos que <code>clone</code> poderia ser utilizado para copiar o valor para uma nova variável.
Entretanto se tentarmos ocorre outro erro de compilação:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    id: u32,
</span><span class="boring">    name: String,
</span><span class="boring">}
</span>fn main() {
    let user_a = User {
        id: 19,
        name: String::from(&quot;Vanius&quot;),
    };
    let user_b = user_a.clone(); // &lt;= Error!
    println!(&quot;User a: {} {}&quot;, user_a.id, user_a.name);
    println!(&quot;User b: {} {}&quot;, user_b.id, user_b.name);
}
</code></pre></pre>
<p>Muitos dos comportamentos semânticos da linguagem são feitos através da
implementação de <em>traits</em> (semelhante a interface) sobre tipos de estruturas.
Por exemplo, para chamar o método <code>clone</code> o tipo deve implementar
o <em>trait</em> <code>Clone</code>.</p>
<p>Num capítulo futuro iremos falar sobre implementação de <em>traits</em>.</p>
<p>A maioria dos tipos nativos do Rust já implementam o trait <code>Clone</code>.
Para o nosso tipo <code>User</code> permitir <em>clone</em> usaremos o recurso de <code>derive</code>.</p>
<p>A <em>derive</em> definimos acima de declarações de itens. A sintaxe é:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Aaa,Bbb,Ccc)]
<span class="boring">}
</span></code></pre></pre>
<p>Para exemplificar um uso iremos usar o <code>#[derive(Clone)]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct User {
    id: u32,
    name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>A <em>derive Clone</em> acaba implementando de forma implícita (invisível)
o <em>trait</em> <code>Clone</code>. Provavelmente ele cria algo como:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn clone(&amp;self) -&gt; Self {
    struct User {
        id: self.id.clone(),
        name: self.name.clone(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>É criada um novo <em>struct</em> fazendo <em>clone</em> de todos os campos.
Por isso para funcionar a <em>derive Clone</em> todos os campos
também devem implementar a <em>trait</em> <code>Clone</code>.</p>
<p>Após isso o nosso exemplo volta a funcionar e compila corretamente:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Clone)]
</span><span class="boring">struct User {
</span><span class="boring">id: u32,
</span><span class="boring">   name: String,
</span><span class="boring">}
</span>fn main() {
    let user_a = User {
        id: 19,
        name: String::from(&quot;Vanius&quot;),
    };
    let user_b = user_a.clone();
    println!(&quot;User a: {} {}&quot;, user_a.id, user_a.name);
    println!(&quot;User b: {} {}&quot;, user_b.id, user_b.name);
}
</code></pre></pre>
<h1 id="api-design"><a class="header" href="#api-design">API design</a></h1>
<p>api design:
https://rust-lang.github.io/api-guidelines/interoperability.html
https://www.philipdaniels.com/blog/2019/rust-api-design/
https://docs.rs/zoet/0.1.6/zoet/
https://deterministic.space/elegant-apis-in-rust.html</p>
<h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>Para debugar em Rust pelo VSCode é necessário a extensão CodeLLDB.</p>
<ul>
<li>Ir na visão de Debug na lateral esquerda.</li>
<li>No botão combo-box de execução clicar na opção <em>Add Configuration...</em>.</li>
<li>Confirme a janela de confirmação.</li>
<li>No arquivo de configuração <code>launch.json</code> pode inserir os parâmetros de <em>command line</em>.</li>
</ul>
<p>Exemplo:</p>
<p><img src="image/debug-vscode.png" alt="Debug VSCode" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
